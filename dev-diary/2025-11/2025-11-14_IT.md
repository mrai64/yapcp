# Diario dello sviluppatore, data 14 novembre 2025

* [index](../index.md)
* [TDL](../TDL.md)
* [project](https://github.com/users/mrai64/projects/1)
_
* [Route](/routes/web.php)
_
* [◀️ ieri](./2025-11-13_IT.md)
* [log](/storage/logs/laravel.log)
* [MAMP base ↗️](http://127.0.0.1:8888/yapcp/public/)
_ [MAMP mysql ↗️](http://localhost:8888/phpMyAdmin5/index.php?route=/database/structure&db=pcpdb)
  bbedit ./storage/logs/laravel.log

## Lista dei voti (una? magari!)

* Lista dei voti per sezione
* Lista dei voti per giurato
* lista dei voti per autore

Versione sezione per sezione.

* dato il totale dei partecipanti proporre
* per ogni voto a scendere quante immagini hanno quel voto
* per ogni voto a scendere, sommato ai voti superiori, la % sul totale dei partecipanti (l'ultimo sarà 100%)

Ogni voto porta a un link che fa vedere la selezione delle opere che hanno ricevuto quel voto.

Alternative: somma dei voti dei giurati, voti distinti per giurati.

Aspetta, però ...

```sql
SELECT
w.*,
cv.*
FROM
    `pcp_contest_votes` cv,
    pcp_works w
WHERE
    cv.work_id = w.id
```

Perché mi esce un set vuoto?  
Stica, ho messo contest_work->id al posto di contest_work->work_id.

Amen,  truncate e vai di seeder.
ma poi rilevo che ci sono dei voti che si assegnano anche 5 volte.

Houston, abbiamo un problema: un concorso, una sezione, un lavoro.
Anche se la sezione è a portfolio, chi carica i lavori Seeder
del concorso non può ignorare che il lavoro va caricato solo una volta.

Ripasso con cancellazione dei doppioni.
Ma va sistemato anche il Seeder di caricamento dei lavori.
Va caricato un lavoro per ogni contest_id, per ogni section_id,
fino al raggiungimento del limite imposto in section.

I voti invece devono essere uno per contest_id, section_id, giurato, e per lavoro.
concorso e sezione, 4 giurati * 208 lavori = 824 voti attesi

section_id: 01a6eb40-b624-446e-9851-092564994cd6, in db mi trovo un contatore di 208,
laravel mi restituisce un set di 96, dice, però se faccio una ricerca dei lavori
che non hanno un voto, trovo il set vuoto.

```sql
SELECT work_id
FROM   pcp_contest_works
WHERE  section_id = '01a6eb40-b624-446e-9851-092564994cd6' 
  AND  work_id NOT IN ( SELECT work_id
                          FROM pcp_contest_votes
                         WHERE section_id = '01a6eb40-b624-446e-9851-092564994cd6' )
```

Quindi?

Andiamo avanti:

Lista dei voti presi dai giurati per ciascun lavoro, mi aspetto che per la select
della section con 208 lavori ci siano 208 risultati.

```sql
-- SUMMA è la 5a colonna
SELECT contest_id, section_id, work_id, count(*) as nvotes, sum(vote) as SUMMA FROM `pcp_contest_votes` 
where section_id = '01a6eb40-b624-446e-9851-092564994cd6'
Group by `pcp_contest_votes`.`contest_id`, `pcp_contest_votes`.`section_id`, `pcp_contest_votes`.`work_id`
ORDER BY 5 DESC, `pcp_contest_votes`.`contest_id` ASC, `pcp_contest_votes`.`section_id` ASC, `pcp_contest_votes`.`work_id` ASC
```

Mysql non mi torna 208 record, me ne torna 144, *STICA*!

`Mostro le righe 0 - 143 (144 del totale, La query ha impiegato 0.0029 secondi.)`

**Risolto**: il caricatore di lavori nel concorso ha caricato sì 208 record, ma ripetendo
poco o spesso i work_id anche nella stessa section, mentre invece non ci devono essere 
2 work_id uguali... Non solo nella stessa section_id ma nello stesso contest_id.

Si crea il problema che per troppe sezioni il caricatore di immagini nel concorso
ContestChargerSeeders ci son pochi lavori e quindi va in loop dopo un po'
per scartare i lavori già caricati.

### rinominati i seeder

Su tutti i file messa una lettera per dare una precedenza alle esecuzioni.
