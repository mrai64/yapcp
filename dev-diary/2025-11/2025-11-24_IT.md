# Diario dello sviluppatore, data 24 novembre 2025

* [index](../index.md) |
  [To Do List](../TDL.md) da svuotare e migrare in |
  [project](https://github.com/users/mrai64/projects/1) issue list  

* [Route](/routes/web.php)  

* [◀️ Diario di ieri](./2025-11-23_IT.md)

* <http://yapcp.test/>
* [log](/storage/logs/laravel.log)  
_

## Database

<https://youtu.be/Kh5-WohujJc?si=I3gSX3J1ufzIWfJ5>

## Disegno db visuale

* <https://www.drawdb.app/>
  Esempio [esportato in md](./2025-11-24_pcpdb_2025-11-24T10_51_09.745Z.md)  
  Facilità d'uso 7 / 8. Esporta anche pdf e dbml

* <https://dbdiagram.io/d>  
  A differenza del precedente, molto web app,
  c'è una "agnostica" del database che consente
  di avere una documentazione utile a molti ambienti
  di sviluppo. importa esporta dbml

* <https://runsql.com/>  
  Questa web app legge un file dbml e consente di avere
  in memory le tabelle popolate anche con copia incolla csv.  
  Serve a testare query comportandosi come un client postgres o mysql.

### X-REFACTOR

Ci sto girando intorno ma ogni volta che ripasso la struttura del db
è perché vorrei cambiare la struttura del db. Avendo adottato le tabelle
ausiliarie per la definizione dei set escludendo gli enum ogni volta
che ne incrocio una che manca dovrei crearla, e inserire la relazione nel database.

Esempio: La tabella ausiliaria *countries*, al momento contiene
le colonne created updated deleted ma soprattutto le colonne id, country et flag.
Volendo aggiungere la region da un set di America, Europe, Asia, ecc.
devo prima creare e caricare la tabella ausiliaria costruendo il
nome tabella con: nome tabella ausiliata, nome del campo ausiliato, e un suffisso sets
che formalmente è sbagliato perché l'insieme è set ed è un set unico
non plurale. Quindi sarebbe corretto vals come abbreviativo di values che rischia di essere frainteso in qualche macro. Avendo già fatto altre tabelle ausiliarie
a gambero dovrei cambiare i nomi di quelle tabelle, e mettere in tutte le tabelle
ausiliate un nome campo estremamente complesso.

es: tabella ausiliata *user_roles*, campo ausiliato *role*  
tabella ausiliatrice *user_roles_role_sets*, campo id string.  
user_roles.role deve diventare user_roles.user_roles_role_set_id  

Alternativa: chiamare la tabella ausiliatrice "solo" roles,  
in questo caso user_roles.role deve diventare "solo" user_roles.role_id

| tabella ausiliata | campo      | tabella ausiliatrice |
| ------------------| ---------- | ---------------------|
| user_contacts     | country_id | countries.id         |
| user_contacts     | user_id    | users.id             |
| federations       | country_id | countries.id         |
| organizations     | country_id | countries.id         |
| contests          | country_id | countries.id         |

Lista da completare

* timezones  
  Si tratta di un elenco redatto sulla base della definizione 2025.2 [vedi php.net](https://www.php.net/manual/en/timezones.php) e attualmente memorizzato in un array nel model TimezonesList.  
  Di fatto *risolve* una tabella ausiliaria che si dovrebbe chiamare timezones, il cui id sia una stringa
  e il Model dovrebbe semplicemente dare atto
  che la chiave primaria è di tipo stringa non incrementabile, senza altre indicazioni.
  la creazione della tabella andrebbe completata con un factory basico e un seeder che contiene l'intero set di valori.

### nuova tabella regions ✅

### nuova tabella timezones ✅

legame con il nuovo timezone_id su:

* contests.timezone
* user_contacts.timezone
* federations.timezone

Fatta la tabella, passati i legami, affibbiata una timezone_id a tutte le federations
che pure non l'avevano, mo quando apro una dashboard mi dice "404"?!? 
E che c'azzecca? Infatti era stato modificato /route/web.php
spostandolo (correttamente) su /user/dashboard, ma non è
stato spostato url('/dashboard') da qualche altra parte.

### Sistemazione UserContact Modify

Cambiando la definizione della lista timezones, l'array che si ottiene
contiene a sua volta un array, $timezone['id'] e non $timezone. E
nemmeno $timezone->id.

