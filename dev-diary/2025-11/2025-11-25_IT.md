# Diario dello sviluppatore, data 25 novembre 2025

* [index](../index.md) |
  [To Do List](../TDL.md) da svuotare e migrare in |
  [project](https://github.com/users/mrai64/projects/1) issue list  

* [Route](/routes/web.php)  

* [‚óÄÔ∏è Diario di ieri](./2025-11-24_IT.md)

* <http://yapcp.test/>
* [log](/storage/logs/laravel-2025-11-25.log)  
_

## Arrivato il link al video di Laravel Day

Per scoraggiare lo scarico integrale il video dura 8 ore e 44 minuti,
720p. Ho cercato in avanti e indietro le schermate del db schema senza trovarle.

* Daniele Barbaro

## Dopo timezone?

Francamente non so se sia stata una buona mossa, l'elenco delle timezone
dovrebbe essere piuttosto statico e quindi la soluzione di mettere
tutto in array non la consideravo una soluzione da buttare.

Altro da mettere in tabella: Y/N. Ma soprassiedo.

## Durante e dopo la giuria

Raccolti i voti e prima della sessione finale della giuria
c'√® la lista dei voti, e con la funzione RANK() posso
vedere sia tutti gli ex equo che le %, come posso indicare ai
giurati qual'√® il set delle immagini a cui dare il üëçüèª +1 o il
üëé -1.

Devo creare una tabella di servizio che contiene per
il concorso+sezione un elenco di work_id da votare.
Come la battezzo: tenendo conto che si devono separare,
potrei sfruttare il concetto di buoni e cattivi
*good guys and bad guys*, ma qui chiedo assistenza
a gemini, tra le varie proposte *seleziona e scarto*
sembra la pi√π adatta, mi viene in mente anche miss Italia
con "per te finisce qui" che pu√≤ essere "forward and stop".

### contest_forward_or_stop_works table

Nella tabella:

* id (va bene anche quello standard bigint unsigned autoincrement)
* contest_id uuid char(36) serve a raggruppare le section_id
* section_id uuid char(36) fa chiave
* contest_work_id uuid char(36) soggetto principale
* unique idx [contest_id, section_id, contest_work_id] la vera pk

Alternative: marcare con una colonna review i voti dei giurati che coinvolgono
quel set di contest_work_id. Dominio ''/'Y'

Mi convince di pi√π quel secondo approccio, visto che cmq vanno
revisionati i voti, all'inserimento viene messo un default '',
alla revisione viene aggiornato con ''.

* creazione colonna
* creazione indice (vedi covering index)
  * section_id
  * juror_user_id
  * review_required
  * work_id (contest_works.work_id)

A questo punto il pannello di vista delle immagini per organizzazione concorso
deve prevedere alcune colonne in pi√π del "minimo"

* section_id (per estrazione ma nascosto)
* vote
* work_id

A cui si aggiunge il

* review_required

E quando viene marcato il flag nella tabella va scatenato un
aggiornamento live su tutti i voti del section_id, work_id; cos√¨
come va fatto l'aggiornamento a '' quando viene smarcato.
La cosa pu√≤ sembrare assurda ma occorre pensare che ci possono
essere click del mouse causali come click del tablet casuali.

Si pu√≤ fare una "aggiunta" ovvero il funzionamento base non prevede
la revisione dei voti e la revisione dei voti funziona come add-on.

Intanto i concorsi in corso stanno sforando tutti i calendari...

* concorso - definizione
* concorso - partecipazione
* concorso - votazione

A questo punto organizzatore del concorso ha una pagina per ciascuna sezione
con un elenco delle votazioni. S√¨, qual'√®?
(dove eravamo rimasti?)

[blade](/resources/views/livewire/contest/section/voteboard.blade.php)
[component](/app/Livewire/Contest/Section/Voteboard.php)

### Voteboard

Questa per ora √® un semilavorato, mi procura la lista *completa* delle immagini.
voto seguito da nazione cognome nome userid e work_id.

1. cambiare la lista completa in una paginazione
2. cambiare i dati da esporre in voto + miniatura immagine

Domanda a gemini

```txt
In Laravel eloquent devo realizzare una query un po' complessa, prende i voti di una tabella concorso di cui ci sono :total_participant_works, con un :contest_id e un :section_id per estrarre l'elenco dei lavori pi√π votati discendente e una percentuale sul numero di voti assegnati pari o superiori. 

SELECT
    vote_data.vote_received,
    vote_data.voted_sum,
    vote_data.work_id,
    -- Usa la funzione RANK() per calcolare la posizione (numero di record con voto >=)
    RANK() OVER (ORDER BY vote_data.voted_sum DESC) AS rank_by_voted_sum,
    (100 * RANK() OVER (ORDER BY vote_data.voted_sum DESC) / :total_participant_works) as PERCENT
FROM (
    -- Subquery per calcolare i voti totali (voted_sum) e il numero di voti (vote_received)
    SELECT
        COUNT(*) AS vote_received,
        SUM(vote) AS voted_sum,
        work_id
    FROM
        `pcp_contest_votes`
    WHERE
        contest_id = :contest_id
        AND section_id = :section_id
    GROUP BY
        work_id
) AS vote_data
ORDER BY
    vote_data.voted_sum DESC;
```

Risposta: serve una funzione che partendo dai
3 dati in input: contest_id, section_id e numero di lavori partecipanti,

```php
use Illuminate\Support\Facades\DB;

/**
 * Esegue la query per ottenere la classifica e la percentuale dei lavori pi√π votati.
 *
 * @param int $contestId L'ID del concorso.
 * @param int $sectionId L'ID della sezione.
 * @param int $totalParticipantWorks Il numero totale di lavori partecipanti in questa sezione.
 * @return \Illuminate\Support\Collection
 */
function getRankedWorks($contestId, $sectionId, $totalParticipantWorks)
{
    // 1. Definisci i parametri che saranno legati (binding) alla query.
    // Questo √® fondamentale per prevenire attacchi di SQL Injection.
    $bindings = [
        'contest_id' => $contestId,
        'section_id' => $sectionId,
        'total_participant_works' => $totalParticipantWorks,
    ];

    // 2. Costruisci la Subquery (la parte interna)
    // Selezioniamo il conteggio dei voti, la somma dei voti e raggruppiamo per work_id
    $subquery = DB::table('pcp_contest_votes')
        ->select(
            DB::raw('COUNT(*) AS vote_received'),
            DB::raw('SUM(vote) AS voted_sum'),
            'work_id'
        )
        ->where('contest_id', $contestId)
        ->where('section_id', $sectionId)
        ->groupBy('work_id');

    // 3. Costruisci la Query Principale (la parte esterna)
    // Utilizziamo la subquery come una "tabella" temporanea
    $results = DB::table(DB::raw("({$subquery->toSql()}) AS vote_data"))
        ->select(
            'vote_data.vote_received',
            'vote_data.voted_sum',
            'vote_data.work_id',
            // Aggiungi le funzioni di finestra RANK() e il calcolo della percentuale
            DB::raw('RANK() OVER (ORDER BY vote_data.voted_sum DESC) AS rank_by_voted_sum'),
            // Il calcolo della percentuale utilizzando il parametro totalParticipantWorks
            DB::raw("(100 * RANK() OVER (ORDER BY vote_data.voted_sum DESC) / {$totalParticipantWorks}) as percent")
        )
        ->mergeBindings($subquery) // **IMPORTANTE**: Unisce i binding della subquery
        ->orderBy('vote_data.voted_sum', 'desc')
        ->get();

    return $results;
}

// Esempio di utilizzo:
// $rankedWorks = getRankedWorks(1, 2, 50);
```
