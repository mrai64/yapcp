# Diario dello sviluppatore, data 22 novembre 2025

* [index](../index.md) |
  [To Do List](../TDL.md) da svuotare e migrare in |
  [project](https://github.com/users/mrai64/projects/1) issue list  

* [Route](/routes/web.php)  

* [◀️ Diario di ieri](./2025-11-21_IT.md)

* <http://yapcp.test/>
* [log](/storage/logs/laravel.log)  
_

## Ambiente sviluppo cambiato, dove vanno i log?

Usavo  
` bbedit ./storage/logs/laravel.log `  
e adesso che spengo `php artisan serve`,  
il log di laravel lo trovo lo stesso lì?  
Spoiler: sì.

### Seeder per i concorsi

Serve realizzare non un solo seeder ma
un blocco di n seeder i quali: carichino un
concorso seguendo alcune regole,
carichino un set di sezioni, un set di giurati, un set di premi.

In TODO LIST

----

## YAH You Are Here

### Elenco dei voti e % sul totale

Alla base della scelta degli ammessi a vincere in concorso, giusto o no che sia,
c'è una somma dei voti
della prima fase che determina quanti vengono ammessi a concorso. I maledetti
*indici di prestazione* vengono declinati in un % di quanti inviano opere
vengono ritenuti papabili a prendere un premio. Gli altri hanno presentato
delle opere formalmente presentabili ma che sono "più scarse". A giudizio e
a gusto, che nei concorsi a circuito si vedono chiaramente scelte divergenti
da giurie diverse sullo stesso tema e sulle stesse opere.

Fatto il concorso e avuto un primo elenco di immagini
in concorso nella sezione tema, serve estrarre uno specchietto che riepiloghi, voto per voto,
quante opere hanno ottenuto quel voto o un voto superiore.

Questo richiede una iterazione sull'interno pannello di opere in concorso in cui vado a prendere i voti,
per contest_id e per section_id (sarebbe sufficiente la seconda,
ma metti caso ma caso! che si ripeta...), e per work_id,
che vadano sommati i voti di tutti i giurati
(ev. correttivo: moltiplicatore dei giurati totali /
giurati votanti)  
POI, per esporre il dato che voglio esporre, NON SI FA
una query, sarebbe una cosa del tipo

*mr Gemini,* voglio la tabella con la somma dei voti raggruppati
per concorso, sezione e lavoro partecipante,
affiancate da un numero in cui riporto la
percentuale dei lavori che hanno avuto lo stesso voto
o uno superiore. Questo è quello che ho fattio io:

```sql
-- conta i voti totali [576]
select count(*) as n_images 
 from pcp_contest_votes 
 where contest_id = 'e8ac5674-c3d1-4afa-adaf-a7d5ed82d292'
  and section_id = '059e0687-f8a4-4dbf-9add-8e9c6ff04ca7';
 
 -- conta quanti lavori [192]
select count(distinct pcp_contest_votes.`work_id`) as n_works
from `pcp_contest_votes`
WHERE
    pcp_contest_votes.contest_id = 'e8ac5674-c3d1-4afa-adaf-a7d5ed82d292'
    AND pcp_contest_votes.`section_id` = '059e0687-f8a4-4dbf-9add-8e9c6ff04ca7';

-- conta quanti artisti [38]
SELECT
    COUNT(DISTINCT pcp_contest_works.user_id) AS n_authors
FROM
    `pcp_contest_votes`, pcp_contest_works
WHERE
    pcp_contest_votes.contest_id = 'e8ac5674-c3d1-4afa-adaf-a7d5ed82d292'
    AND pcp_contest_votes.`section_id` = '059e0687-f8a4-4dbf-9add-8e9c6ff04ca7'
    and pcp_contest_votes.work_id = pcp_contest_works.work_id;
    
-- elenco dei voti a discesa [66 .. 40]
select 
 count(*) as vote_received,
 sum(vote) as voted_sum,
 work_id 
 from pcp_contest_votes 
 where contest_id = 'e8ac5674-c3d1-4afa-adaf-a7d5ed82d292'
  and section_id = '059e0687-f8a4-4dbf-9add-8e9c6ff04ca7'
  group by contest_id, section_id, work_id
  order by voted_sum DESC;
```

Questo è quello che ha proposto *mr Gemini*:

```sql
-- Numero di lavori con un voto uguale o maggiore di 
-- Ordine di arrivo RANK() courtesy gemini.google.com 
SELECT
    vote_data.vote_received,
    vote_data.voted_sum,
    vote_data.work_id,
    -- Usa la funzione RANK() per calcolare la posizione (numero di record con voto >=)
    RANK() OVER (ORDER BY vote_data.voted_sum DESC) AS rank_by_voted_sum
FROM (
    -- Subquery per calcolare i voti totali (voted_sum) e il numero di voti (vote_received)
    SELECT
        COUNT(*) AS vote_received,
        SUM(vote) AS voted_sum,
        work_id
    FROM
        `pcp_contest_votes`
    WHERE
        contest_id = 'e8ac5674-c3d1-4afa-adaf-a7d5ed82d292'
        AND section_id = '059e0687-f8a4-4dbf-9add-8e9c6ff04ca7'
    GROUP BY
        work_id
) AS vote_data
ORDER BY
    vote_data.voted_sum DESC;
    
```

Risultato figo

![Risposta della query con le posizioni in classifica RANK()](./2025-11-22%20alle%2015.04.06.png)

La riposta in % che interessa me viene calcolata con il rank * 100 / numero di partecipanti.

```sql

-- Numero di lavori con un voto uguale o maggiore di 
-- Ordine di arrivo RANK() courtesy gemini.google.com 
SELECT
    vote_data.vote_received,
    vote_data.voted_sum,
    vote_data.work_id,
    -- Usa la funzione RANK() per calcolare la posizione (numero di record con voto >=)
    RANK() OVER (ORDER BY vote_data.voted_sum DESC) AS rank_by_voted_sum,
    (100 * RANK() OVER (ORDER BY vote_data.voted_sum DESC) / :total_participant_works) as PERCENT
FROM (
    -- Subquery per calcolare i voti totali (voted_sum) e il numero di voti (vote_received)
    SELECT
        COUNT(*) AS vote_received,
        SUM(vote) AS voted_sum,
        work_id
    FROM
        `pcp_contest_votes`
    WHERE
        contest_id = :contest_id
        AND section_id = :section_id
    GROUP BY
        work_id
) AS vote_data
ORDER BY
    vote_data.voted_sum DESC;
...
```

![Ecco la percentuale](./2025-11-22%20alle%2015.15.56.png)

Servono bind su :contest_id, :section_id et :count_works_participant

A questo punto, posto che riesca ad avere la lista dei lavori che sono
"a cavallo" di una percentuale di soglia, devo realizzare un giro di
votazioni da rifare ai giurati che decidano a chi dare +1 a chi dare -1
in modo da spostare la % entro un limite richiesto dalle federazioni.

Punto 2: se devo usare DB::table() "perdo" le relazioni che da
contest_votes.work_id mi portano a contest_works.id e dq qui
a user_contacts.user_id con i loro dati. Ma non ho alternative:
devo delegare la lettura di quei dati a una livewire component
dedicata all'esposizione dei dati per l'organizzazione che
ha creato e gestisce il concorso.

### Rintracciare le regole di % per i concorsi FIAF

A oggi [regolamento vigente](https://fiaf.net/wp-content/uploads/2025/09/REGOLAMENTO-CONCORSI-REVISIONE-2026_1-0.pdf).  
**Premi** Limitare il numero d riconoscimenti per sezione al 5% delle fotografie ammesse, minimo 3 prem ufficiali per sezione (regolamento vigente 1.4. Premi)

Non c'è altro.

Qui torna la "vecchia questione" dei campi aggiunti richiesti dalle federazioni, che per la FIAF sono ad esempio la tessera dell'autore, il suo codice fiscale per l'autore e l'anno di prima ammissione per i titoli delle opere. Che, da regolamento, devono essere esposti alla giuria (sempre? eventualmente?)

**costruzione dei moduli** form con classi php es.
[Laravel Form Builder](https://github.com/kristijanhusak/laravel-form-builder),

Il comportamento della vista delle foto deve pure questo essere soggetto a varianti di federazione. Devo quindi prevedere dei campi (eventualmente a solo uso interno) che guidino le alternative di gestione.

E questi dove vanno piazzati? Li devo inserire nella tabella federation_sections e *per ereditarietà* nella tabella contest_sections.

Va installato e studiato, in sostanza a me serve creare
un form che a fisarmonica si può allungare con ulteriori campi.
"fatto 30 si fa 31", e quel campo in più è quello richiesto dalla federazione XXXX.

**Campi standard e Campi aggiuntivi**  
l'elenco dei campi può diventare quindi una tabella con dati
associati al form, sequenza, label, campo, tipo, valori predefiniti
o regole di validazione... Tutto in un tabellone.
