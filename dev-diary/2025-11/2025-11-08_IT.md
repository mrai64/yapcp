# Diario dello sviluppatore, data 8 novembre 2025

* [index](../index.md)
* [TDL](../TDL.md)
* [project](https://github.com/users/mrai64/projects/1)
_
* [Route](/routes/web.php)
_
* [◀️ ieri](./2025-11-07_IT.md)
* [log](/storage/logs/laravel.log)

## Timeout, ancora timeout. Paginazione?

* Studiare il debugbar
* Studiare la paginazione standard
* studiare la personalizzazione della paginazione standard
* Realizzare un coso che prepari una pagina statica di listino

L'esigenza da risolvere qual'è:  
Si tratta di fornire l'elenco completo di qualcosa;
per i concorsi
può essere l'elenco completo dei concorrenti partecipanti
con il loro riassunto dei dati: nazione, cognome, nome, status di iscrizione in corso / completata, e - per ogni sezione tema del concorso - quante opere hanno deciso di caricare. Questo elenco si può paginare? Sì, senza se senza ma. Al più, visto che le tabelle hanno dei dati da non pubblicare / che non interessa pubblicare, la select può diversificarsi dal solito select * e limitare le colonne che vengono esposte. Si vuole la bandiera al posto del codice nazione? si può fare una query complessa piuttosto che delegare alla blade la lettura di country->flag_code. Serve un file excel con lo stesso contenuto dell'elenco? A farla semplice si prepara un file di testo contenente una table html e lo si manda in scarico cme excel.xls. Quando excel lo apre brontola ma lo apre come tabella senza storie e si può salvare come excel "genuino".

E' un problema anche presentare il catalogo del concorso paginato? Diventa un problema quando ci si confronta con altre piattaforme che gestiscono nativamente qualche centinaio di opere per ogni sezione. Diventa un problema quando la paginazione è ampia e sfonda comunque il limite dei 30 secondi.

Tentativi da fare:

[Tutorial paginazione](https://youtu.be/m5riTIqb8H0?si=S1_F_EX3KTEXnHGK)

* pagina con impostazione header + table + tbody foreach(tabella as elemento) ✅
* viene sostituito ->get() nel component con paginate(15)
* viene mezzo sotto alla tabella una classe per i lnk della paginazione

Serve quindi una Contest [Section List](/app/Livewire/Organization/Contest/Section.php)
che faccia il caricamento dei contest_works.work_id e da quelli carichi i works.*
oppure che dai works.* selezioni gli id presenti della section_id con un INNER JOIN

select uw.*
from works uw, contest_works cw
where (uw.id = cw.work_id)
  and (cw.section_id = :section_id)

select uw.*
from works uw
where uw.id in (select work_id from contest_works cw where cw.section_id = :section_id)

select uw.*
from works uw
inner join contest_works cw
on uw.id = cw.work_id
where cw.section_id = :section_id

$works_set = DB::table( WORK::table_name )
    ->join(ContestWork::table_name, WORK::table_name.'.id', '=' , ContestWork::table_name.'.work_id' )
    ->get();

$works_set = DB::table( 'works' )
    ->join( 'contest_works', fn(JoinClause $join){
      $join->on( 'works.id', '=', 'contest_works.work_id' )
        ->where( 'contest_works_id', '=', $section_id);
    })
    ->get();

Questa scorciatoia consente di fare in millisecondi quello che prima prendeva
due secondi, e ci metto il paginate(15) al posto di get().
Nel tutorial non viene toccato niente e piazzato un paginate navbar,
con la funzione ($set)->links();

Problemi non riconosciuti, se metto la get non esiste ->links(), se metto paginate mi dice
un generico *property not supported*
