# Diario dello sviluppatore, data 14 ottobre 2025

* [index](../index.md)

* [TDL](../TDL.md)
* [project](https://github.com/users/mrai64/projects/1)
* [◀️ ieri](./2025-10-13_IT.md)
* [log](/storage/logs/laravel.log)

## Relazioni tra tabelle

Posto che farlo quando si creano le tabelle
è *per definizione* più semplice, creare una
relazione tra tabelle quando sono caricate
comporta l'uso di una tabella di travaso, in cui
caricare i dati, la cancellazione (ammesso che
ci si riesca) e ricreazione della tabella
correlata, il travaso di ritorno dei dati. Per
ora si fa niente, ma intanto la relazione
(manualmente, in phpMyAdmin) l'ho creata.
Intanto le funzioni di connessione hasOne e
belongsTo le ho inserite nei Models.

## Cose da fare

### feat: User Roles: Juror *end-of-role date* must be *contest.end-of-jury+1day* id:2025-09-28.06 #7

* La tabella user_roles contiene record juror che hanno
  * lo stesso user
  * lo stesso ruolo juror
  * lo stesso organization_id NULL
  * lo stesso federation_id NULL
  * lo stesso contest_id
  * data role opening differente per orario

Deve essere modificata la creazione del record
per usare come role_opening una data con orario
00:00:00, e se il record risulta già presente
non deve creare errore. Si deve tenere in linea
il dato del contest che nel calendario ha il campo
day_4_jury_closing. La data di fine mandato deve essere
quella data con orario 23:59:59.

Si può usare un metodo ~~insertOrUpdate()~~ sì, ma si chiama updateOrCreate().

#### orario contest: jury_opening con orario 00:00:00 jury_closing con orario 23:59:59

La modifica che assegna gli orari ha funzionato, e
comunque vengono inseriti i record doppi.
Decido di passare al modo vecchio, se il conteggio
dei record da  zero inserisco altrimenti tiro dritto.

Funziona **commit**

## user_roles non sarà troppo complicata?

Può "esplodere" in tre tabelle:  user_organizations_roles, user_federations_roles, user_contests_roles.

## Refactor DB

Elenco tabelle, quello che c'è ora:

* cache laravel
* cache_locks laravel
* contests  
  Va abbinata a una tabella contests_is_circuit_sets  
  All'interno della tabella **sets due valori
  Y / N  
  e regola 1:1: constrains() tra tabella contests*..._sets e tabella contests  
  va abbinata alla tabella countries con
  legame 1:1 tra contests.country_id e countries.id
* contests_is_circuit_sets da creare e non fare model  
  *Perché?* Si tratta di una tabella che
  esplicita un dominio di valori e non comporta un *"payload"* aggiuntivo a differenza
  di users e user_contacts.  
  Quindi ogni modifica alla tabella *se mai si farà*
  sarà fatta direttamente in DB
* contest_awards  
  tabella collegata principalmente a contests_sections,
  ma quando la key di contest_sections
  manca, si collega a contests
* contest_juries  
  tabella collegata a contest_sections
* contest_payments_fee_payment_completed_sets  
  Anche questa tabella è un set di valori per il campo
  fee_payment_completed della tabella contest_participants.  
  Anche questa non avrà Model
* contest_participants  
  tabella collegata a contests e a users
  e a contest_participants_fee_payment_completed_sets
* contest_sections  
  Tabella correlata a contests e a federation_sections
* contest_works
  tabella correlata a users/user_contacts,
  a works, ed a contest_sections
* countries
  tabella con pk che non è incrementale ne uuid, fa da rifermento per molte tabelle
  comprese user_contacts, contests,
  organizations, federations
* failed_jobs laravel
* federations  
  legata alla tabella countries e alla
  tabella user_roles,
  legata indirettamente alla tabella
  contests in cui vengono usati
  i federations.code
* federation_sections  
  legata alla tabella federations e alla
  tabella contest_sections
* jobs laravel
* job_batches laravel
* migrations laravel
* organizations  
  legata alla tabella countries, alla
  tabella user_roles, alla tabella contests
* password_reset_tokens laravel
* sessions laravel
* users laravel
* user_contacts  
  legata alla tabella countries e alla tabella users
* user_roles  
  legata alla tabella user_contacts, alla tabella organizations, alla tabella federations
  alla tabella contests.
* user_roles_role_set  
  legata alla tabella user_roles, contiene un set di
  valori utilizzabili nel campo role della tabella
  user_roles. Non si crea Model
* works  
  la tabella si potrebbe chiamare user_works, legata alla tabella user_contacts

Quello che c'è ora. L'elenco non è completo, manca di tabelle ancora da definire, quella dei voti dei giurati, per esempio.

Si può fare un refactor per stralci.

1. Esportare la tabella A interessata, usando phoMyAdmin
2. fare drop della tabella A,
3. creare le tabelle A_nomecampo_sets la tabella A con il constrain,
4. ricaricare la tabella A da phpmyadmin

Sostanzialmente questo si farà se la tabella è già in produzione ma richiede comunque
un periodo di stop.

## cose da fare (vedi ieri)

Iscrizione dei lavori / opere / works a concorso. Contestualmente
all'iscrizione del lavoro fare un check se l'autore è presente
per il concorso nella lista dei partecipanti nella tabella contest_participants.
Se manca, va aggiunto.
[vedi anche](/app/Livewire/Contest/Subscribe/Add.php)

Specchio riflesso. Se quando rimuovo/smonto le opere dal concorso mi
trovo che era l'ultima, devo contestualmente togliere l'autore dalla
tabella contest_participants.
[vedi anche](/app/Livewire/Contest/Subscribe/Remove.php)

Pronto ma da verificare. Concorso con concorrenti:
4th Alfredo Matacotta ecc. Concorrenti: Massimo Calone.
Lavori iscritti: zero. Aggiungere 2 immagini, verificare.
Levare 1 immagine. Verificare. Levare 1 immagine. Verificare.

Nota: get() -> collection/array first() -> istanza/metodi

FUNZIONA **commit**