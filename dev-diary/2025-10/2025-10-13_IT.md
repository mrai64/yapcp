# Diario dello sviluppatore, data 13 ottobre 2025

* [index](../index.md)
* [TDL](../TDL.md)
* [project](https://github.com/users/mrai64/projects/1)
* [◀️ ieri](./2025-10-12_IT.md)
* [log](/storage/logs/laravel.log)

## Complicazioni

Occorre puntare a un codice più semplice, nei tutorial non
sono utilizzati `->get()[0]` e quindi deve esserci anche un sistema più
elegante e facile di gestire i dati che viaggiano per
l'aggiornamento dei dati. Anche i tempi di risposta credo ne risentano,
sono in un localhost e ho dei tempi di risposta di parecchi secondi.

Una delle basi di laravel sembra sia la scomposizione, per fare
una cosa semplice servono una mezza dozzina di cose incasellate
al loro posto, niente si fa senza un legame che non sia `use (...)`.

Spesso si passa una intera istanza, e non so se sia un bene
o se prenda in carico più spazio memoria per gestirla.
Per esempio la lista partecipanti, posso avere nel model
solo la lettura della lista e nel blade usare dei componenti che
poi ciascuno si va a pescare il nome, il cognome, la bandiera del paese,
ecc.  
Oppure posso avere la lettura della lista, caricarmi la lista
dei partecipanti e passare tutti gli elementi al blade che li espone
avendoli già caricati.  
Sono due approcci diversi e non ho elementi in mano per preferire uno
o l'altro.

## Relazioni (tra tabelle)

Riprendo l'argomento [Eloquent Relationship](https://laravel.com/docs/12.x/eloquent-relationships)
e trovo un esempio in [vedi tutorial](https://youtu.be/NU1-NUM0LYs?si=YelIpy8g-HEK3e6y)

In questo tutorial la tabella users e la tabella profile hanno una relazione 1:1 come è per "le mie" users e user_contacts

1. Viene definita la relazione nel migration con una colonna foreignXXXX
(che può essere foreignId | foreignUuid)
1. tenere presente che la tabella users "padre",  
la tabella Profile "figlio" anche se sono 1:1
1. Viene messo nella classe User (padre) un getter `profile()` per tirare fuori i dati dalla classe Profile con `hasOne(Profile::class)`
1. Si può mettere nella classe Profile un getter `user()` per tirare fuori i dati della classe genitore con `belongsTo(User::class)`

Risultato: si può accedere ai dati della tabella Profile dalla classe User
con un elegante user->profile()->datidellaclasseProfile.

C'è poi da "normalizzare" il rapporto di allineamento da forzare per il campo
user->email vs. user_contacts->email. Posso anche "passare da user" per
avere il campo ma ... saperlo.

Per le relazioni 1:N non ci sarà solo 1 record nella collection di ritorno,
l'esempio è per i post e le categorie dei post.
N record Post hanno 1 record POst_category

* Si vogliono leggere tutti i post che hanno una categoria  
`posts(PostCategory $post_category){`  
`  return $post_category->posts;`  
`}`  

Nel model PostCategory  
hasMany al posto di hasOne

Nel model Post  
ancora belognsTo()

Nel "mio la relazione 1:N  
c'è tra user e works  
c'è tra organization e contest  
c'è tra user e contest_juror  
