# Diario dello sviluppatore, data 15 ottobre 2025

* [index](../index.md)

* [TDL](../TDL.md)
* [project](https://github.com/users/mrai64/projects/1)
* [◀️ ieri](./2025-10-14_IT.md)
* [log](/storage/logs/laravel.log)

## Relazioni tra tabelle - sospendere tutto

Sospendere le operazioni. Il poco che sarebbe da fare:

1. creare le tabelle di set con i caricamenti dei dati
1. creare i "giusti" migration per legare le tabelle di set con le tabelle principali
1. creare le tabelle di relazione con i legami alle tabelle principali
1. creare un backup con istruzioni per inserimento di singolo record
1. creare factory e seeder per popolare user_contacts, user_works
1. brasare tutto il db e ricrearlo
1. ricaricare le tabelle di set
1. ricaricare le tabelle principali
1. creare utenti, ruoli in federazione, organizzazioni, ruoli in organizzazioni
1. cominciare a caricare i primi concorsi
1. cominciare a iscrivere lavori a concorsi
1. definire chi ha pagato e chi non ancora

E verificare che tutto funziona, aggiustando quello che si blocca, ecc. Forse va via "solo" una settimana di lavoro.

A questo punto i campi che sono definiti Y/N possono
anche diventare bool true false e semplificare le
espressioni, mentre si complica giusto un poco
la loro visualizzazione che prevede un input checklist
checked / unchecked.

A questo punto si può creare anche una tabella per i circuits, che sono inseriti nella struttura dei concorsi ma devono escludere alcune parti e quindi sono "una cosa diversa". Se non è tutto da rifare, di sicuro si può rifare molto sconfessando le "idee" iniziali.

## Next Step

* Caricare dati
* Pagina lista dei lavori iscritti per organizzazione
  * elenco partecipanti ammessi per statistiche
* Tabella votazioni concorso
* Pagina per i giurati per la votazione su miniature e per lista dei voti con riassunto: quali voti quante opere.
* Pagina dei giurati per votazione su schermata video intero
* i voti dei giurati non vanno aggiornati, va cancellato il voto vecchio e inserito il voto nuovo.
* Pagina chairman con i voti dei giurati e statistiche generali quali voti quanti voti.
* Creare modulo di richiesta di revisione voti per le immagini che sono "al bordo sotto" e impediscono al concorso di rientrare nelle % di ammissioni previste dalle federazioni.

## fix: Contest list show same Organization for all. [id:2025-10-15.01] #34 [bug]

* url > route web > class / blade

* Sistemata la query che tornava sempre il primo inserito,

funziona **commit**

## caricamento dati

* utenti users+user_contacts  
  Da questa viene che user->contact, ma nel caso anche user_contact->password
  o pure user_contact->verified_at
  vorrei creare un caricamento un po' più coerente con quello fatto a mano.
  * nome e cognome finti
  * indirizzo <nome.cognome@athesis77.it>
  * password generata dalla email
  * tutto il resto a default
* user_contacts
  * for every user
  * user_contatcs.first_name <- users.name
  * user_contatcs.last_name <- users.name
  * user_contacts.email <- users.email
  * user_contacts.country_id <- una tra quelle di countries.id
  * user_contacts.cellular <- finto ma con prefisso della nazione country_id
Fatto e risolto un problema poco chiaro: l'inserimento mi diceva che mancavano delle colonne '0' e '1'

```php
SQLSTATE[42S22]: Column not found: 1054 Unknown column '0' in 'field list' (Connection: mysql, 
SQL: insert into `pcp_user_contacts` (`0`, `1`, `first_name`, `last_name`, 
`email`, `created_at`, `updated_at`, `deleted_at`) values

```

Questo perché il primo rigo non era

```php
  UserContact::create([ 
        'user_id'    => $user->id,
``
ma era

```php
  UserContact::create([ 
        'user_id',     $user->id,
``

E quindi no sapeva come si chiamano la colonna '0' e la colonna '1' da assegnare a:

```php
values (user_id, 0199e6e8-d7b5-70ba-b8b2-7b99afd7f1cc, 
```

## ON DELETE RESTRICT | CASCADE?

* Tabella P è padre
* Tabella F è figlio
* Relazione 1:1 o 1:N non cambia
* campo F.user_id è legato a campo P.id

* `ON DELETE RESTRICT`  
  Quando viene cancellato p.id l'operazione viene bloccata fintanto che ci sono anche uno solo F.userid con lo stesso valore

* `ON DELETE CASCADE`  
  Quando viene cancellato P.id a cascata vengono cancellati anche tutti i record di tutta la tabella F che hanno pari F.user_id

* `ON UPDATE RESTRICT`  
  Caso raro ma non impossibile, viene **cambiato**
  users.id, ma non si può fare il cambio se esistono già
  dei record che puntano al F.User_id *vecchio*
  (sempre se ho capito giusto)

* `ON UPDATE CASCADE`  
  Se cambia P.id a cascata viene cambiato f.user_id
  dove si trovava il codice vecchio.
  (e mi sembra il più normale)

C'è anche da dire che: i *trigger* sono gestiti da mysql direttamente e i *constrain* sono gestiti da InnoDb che è una parte di mysql ma non mysql base. Questo porta dei problemi se si è convinti di una coerenza e con-sequenza di comportamento tra questi.
