# Diario dello sviluppatore, data 11 ottobre 2025

* [index](../index.md)
* [TDL](../TDL.md)
* [üîµ project](https://github.com/users/mrai64/projects/1)
* [‚óÄÔ∏è ieri](./2025-10-10_IT.md)  
* [log](/storage/logs/laravel.log)

## Prossimo step

### Lista dei partecipanti (2)

Segue da [ieri](./2025-10-10_IT.md#lista-dei-partecipanti-2)

#### Middleware per le abilitazioni

L'utente deve essere:

* registrato
* verificato
* presente nella tabella user_roles
  con legame al concorso

Nella documentazione di laravel si parla di
[Gates](https://laravel.com/docs/12.x/authorization#gates) e di
[Policies](https://laravel.com/docs/12.x/authorization#creating-policies).
Gates ha molte traduzioni, si pu√≤ tradurre con tornelli.
Policies invece ha una traduzione meno varia, Politica, ma politica ha
molte accezioni. Se i tornelli sono una versione base delle autorizzazioni
le politiche si applicano tramite delle classi, quindi possono
avere metodi - funzioni piuttosto articolati.  
[RACF](https://en.wikipedia.org/wiki/Resource_Access_Control_Facility)
in mainframe √® stato uno dei primi *gestori di accesso*
che ho incontrato, mentre in seguito all'interno delle applicazioni c'erano
livelli di abilitazione per singoli utenti e per gruppi a cui appartiene
l'utente, la cosa era monitorata da un ufficio dedicato.

Per un concorso quindi dedicare un Gates o una Policy? Dovendo fare
verifiche basate su accessi a tabelle, sar√† il caso di creare delle Policy.
Ma prima guardo ai Gates, magari anche questi sono usabili.  
[Vedi tutorial](https://youtu.be/4gJSaziBKEc?si=nQAzMTpoQMFvwqvK)  
Si parte sempre da `Auth::id()` che √® associato alla tabella User.
Nei metodi delle classi si usano Gate::authorize() e nei blade @can .. @endcan

```php
$ php artisan make:policy ContestPaymentChangePolicy

   INFO  Policy [app/Policies/ContestPaymentChangePolicy.php] created successfully.  

```

Questa classe deve verificare se user_id √® abilitato a modificare il campo
`fee_payment_completed` nella tabella `contest_participants`  
**preliminare**:

* che il concorso esista
* che oggi non sia gi√† scaduto il termine di partecipazione

**Almeno una** delle:

* √® Auth::id()  
Anche il concorrente pu√≤ modificare il suo status di pagamento,
aggiungendo in futuro un allegato pdg o jpg la ricevuta di pagamento. (creare un issue dedicato)
* fa parte delle persone legate al `contest_id` nella tabella `user_roles`
(escluso role `juror`, con role `chairman`?)
* √® membro di `organization_id` che ha
inserito e gestisce il contest. Per i circuiti si far√† rifermento al
record del circuito con is_circuit === 'Y'.

Per gli ultimi due serve un accesso per user_roles con user_id e federation_id nullo
verificando poi che ci siano record con organization_id o con contest_id.

### Va sempre controllato il giro prima di approfondire la scrittura del software

Policy preparata, ma dove va messo il Gate()? Vedi tutorial precedente.

Ma a chi si applica? La pagina √® ancora da preparare.

```php
$ php artisan livewire:make Contest/Participants/Modify
 COMPONENT CREATED  ü§ô

CLASS: app/Livewire/Contest/Participants/Modify.php
VIEW:  resources/views/livewire/contest/participants/modify.blade.php
```

Le verifiche possono stare gi√† nella pagina di route? nel metodo mount()?

```php
$ php artisan livewire:make Contest/Participants/Remove
 COMPONENT CREATED  ü§ô

CLASS: app/Livewire/Contest/Participants/Remove.php
VIEW:  resources/views/livewire/contest/participants/remove.blade.php
$ php artisan livewire:make Contest/Participants/Complete
 COMPONENT CREATED  ü§ô

CLASS: app/Livewire/Contest/Participants/Complete.php
VIEW:  resources/views/livewire/contest/participants/complete.blade.php
```
