# Diario dello sviluppatore, data 12 ottobre 2025

* [index](../index.md)
* [TDL](../TDL.md)
* [project](https://github.com/users/mrai64/projects/1)
* [◀️ ieri](./2025-10-11_IT.md)
* [log](/storage/logs/laravel.log)

## Prossimo step

### Lista dei partecipanti (2)

Segue da [ieri](./2025-10-11_IT.md#lista-dei-partecipanti-2)

#### Middleware per le abilitazioni

Ieri ho fatto il primo giro con Gates e Policy, o vero ho
limitato la modifica di una lista solo al diretto interessato.
Oggi c'è da fare la verifica che uno che fa capo all'organizzatore
del concorso abbia accesso a tutti gli elementi della lista.

Poi lo stesso criterio di gate andrà applicato anche altrove.
C'è chi può. E chi no.

### Viste, ma quelle del database

Nel database ci sono le tabelle e poi esiste una query "predefinita"
che viene chiamata anche quella VIEW.  
A differenza delle tabelle non ha bisogno di migration, factory e seeder,
ma si può creare comunque con una migration come fosse una tabella.
E creare un model che usa la view per leggere dati. Infatti queste
VISTE sono solo ed esclusivamente di lettura, non prevedono né
inserimenti né modifiche.

```php
$ php artisan make:migration create_user_roles_views_table

   INFO  Migration [database/migrations/2025_10_12_133101_create_user_roles_views_table.php] created successfully.  
```

In seguito nel model occorre ridefinire il nome della tabella puntando alla view.
[vedi anche](https://laravel.com/docs/12.x/eloquent#table-names)

```php
  protected $table = 'user_roles_view';
```

Questa tabella NON ha primary key, o meglio: va creata una colonna 'id'
che si può(?) abbinare a un datetime ma di fatto non viene usata.

D.: Le view possono avere indici?  
R.: No, non sono tabelle. Conviene crearle già con un *order by* utile.

### user_contacts hasOne users

Anche se chi viene creato per primo è il record in users,
quello che comanda sarà sempre user_contacts. Quindi quando cambia
user_contacts.email va cambiato anche users.email.  
Però nessuno dei due è chiave.
Si può passare tramite `Eventi`, quando viene modificato user_contacts.email un Listener aggiorna users.email ricevendo user_contacts

In alternativa si può fare che ma email di user_contacts sia pescata
per dipendenza da users.email
