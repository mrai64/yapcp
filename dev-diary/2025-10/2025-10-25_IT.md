# Diario dello sviluppatore, data 25 ottobre 2025

* [index](../index.md)
* [TDL](../TDL.md)
* [project](https://github.com/users/mrai64/projects/1)
_
* [Route](/routes/web.php)
_
* [◀️ ieri](./2025-10-24_IT.md)
* [log](/storage/logs/laravel.log)

## Elenco delle opere in concorso per giurato [feat: Contest Works Participant List for Juror \[id:2025-10-22.02\] #45](https://github.com/mrai64/yapcp/issues/45)

Segue da ieri.

Verifica manuale immagini per quello che non è possibile automatizzare
nel periodo dalla presentazione /iscrizione delle immagini a concorso
fino a quando iniziano i lavori della giuria.
Serve scartare delle immagini mandando all'autore un avviso che se
in tempo possa sostituire l'immagine che sarà stata sfilata dal concorso
per un giustificato motivo.

Creata tabella contest_waitings

Viene registrato chi fa la osservazione, l'osservazione.
Ma se la foto va bene si può anche memorizzare per l'opera che un controllo
è già stato fatto e "saltarlo" per verifiche in altri concorsi
che usano la stessa sezione. La convalida deve essere sulla foto
e indipendente dal concorso ma legabile a una sezione federazione

Il "concorso X", italiano ha la sezione FIAF:BN? L'immagine
vien validata per la sezione ?

* (user_)work_id
* federazione_sezione_id
* user_id convalidatore
* data_convalida

E questa può fare da guida per limitare il lavoro dl concorso X seconda edizione
o del Concorso Y che segue. Allo stesso tempo se l'immagine è in contest_waiting
per il concorso X, anche al concorso Y può interessare esaminarla per verificare
se la contestazione è valida.

Creare la tabella work_validations

Alla tabella work_validation serve un id uuid? Ma anche no, le ricerche
dovrebbero essere per work_id, quindi non essendo agevole fare le chiavi
PRIMARY in due o più colonne, scelgo di lasciare un id incrementale classico.

Quindi adesso la lista dei lavori in concorso, sezione per sezione

* versione liscia  
prende tutti i lavori messi a concorso e li mostra,  
il convalidatore sarà un membro dell'organizzazione del concorso
e sceglierà *lavoro per lavoro* se va bene o se ci sono problemi
  * va bene. ok allora:
    * viene inserito un record nella tabella work_validations
    * viene copiata l'immagine nelle cartella \concorso\sezione
  * NON VA bene, ... Ok allora:
    * viene aperta una pagina in cui il convalidatore deve scrivere perché
    * viene inviata una email all'autore, educata che può sempre essere in buonafede
    * viene rimosso il lavoro dai lavori in concorso (soft-delete)
* versione quasi liscia
  * l'elenco non è di tutte le opere ma di tutte quelle
    no sono presenti nella tabella work_validations
    per la stessa sezione

Problema: avere la coppia di chiavi federation_id + section_code
consente di identificare il record della sezione,
ma in concorso c'è il federation_id da una parte
e un codice section_code che "prende ad esempio"
la federation_section ma NON è la federation_section.

Adotto quindi la relationship per trovare i dati passando solo un federation_sections.id

Lavori che sono pronti in concorso, se sono anche in
elenco dei validati per lo stesso ...? Se la section del
concorso è legata a niente? non ci sarà section nei validati
Lavori che hanno una section ma non sono patrocinati:
passano tutti in elenco, che non ci sono sezioni
di federazione a cui fare riferimento.
Lavori che hanno una section patrocinata da una federazione,
in quel caso vale la legge dell'ELSE:  
se espressione A (and)  
  se espressione B  
    fai qualcosa senza visibilità - echo ""
  ELSE  
    fai qualcosa con visibilità  
  fineSe
fineSe

Route::put() o route::port sono quelle deputate
all'inserimento dati e però richiedono la presenza di un
form, anche di campi hidden ma con un pulsante.
