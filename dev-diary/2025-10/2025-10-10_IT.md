# Diario dello sviluppatore, data 10 ottobre 2025

* [index](../index.md)
* [TDL](../TDL.md)
* [project](https://github.com/users/mrai64/projects/1)
* [◀️ ieri](./2025-10-09_IT.md)
* [log](/storage/logs/laravel.log)

## Prossimo step

### Reformat tabelle contest_works (nuova) e contest_participants

Creata la tabella contest_participants, versione 2. Creare in automatico dei
concorsi comporta un sacco di lavoro. Sistemare il Model, creare le pagine per Participant List.
Se lo user_id in linea Auth::id() ha uno user_role() nel concorso può
cambiare lo stato della quota di iscrizione "da pagare" a "pagato" con un click.

Nella Participant List devono anche essere elencate a parte le sezioni del concorso
e quante opere per ciascun partecipante sono iscritte a concorso.

Malsana idea: non aggiungere la colonna pagamento. Primo perché serve qualcosa che
decida in automatico la quota da versare, e può essere una quota fissa per autore,
una quota fissa per autore diversa se usa un codice sconto, una quota diversificata
se partecipa in due o più sezioni. Si farà ma non è un obiettivo urgente.

## Studiare: Relazioni tra tabelle [vedi](https://laravel.com/docs/12.x/eloquent-relationships)

Passando la malsana idea del pagamento sono andato a vedere quali
siano i *tipi* di campi previsti oltre al float che consentono i decimali.
Nessuno, nemmeno un unsignedFloat. Allo stesso tempo ho trovato dei tipi
uuidMorph ulidMorph che hanno attratto la mia attenzione. In qualche modo
si vuole anticipare al sistema che ci sono campi uuid in relazione tra tabelle.
Sono anche previsti dei metodi dedicati *hasOne*, *belongsTo*
A me non mancano tabelle correlate ma questo sistema di indicazioni che applicazione ha?
Velocizza le ricerche? Per esempio in molte tabelle devo estrarre dei dati basandomi su uuid,
che banalmente possono essere nome, cognome di uno user uuid, il nome del concorso con il suo uuid
e così via.

Users e User_Contacts, relazione 1:1
In questo caso users è la registrazione di email e password per accedere al sistema che
è separata dalla gestione dei dati anagrafici e di contatto, ma c'è una relazione 1:1
Quindi posso definire nella classe User HasOne() e ottenere la class UserContac

```php
public function contact(): HasOne
{
  return $this->hasOne(UserContact::class);
}

// e ottenere la scheda con un semplice
  $contact = User::find( 'a1b2c3-...' )->contact;
```

Quando i nomi delle colonne consentono un facile abbinamento, *users.id <-> user_contacts.user_id*  
I campi nella migration li ho definiti come foreignUuid, ma esiste anche un'altra definizione
<https://laravel.com/docs/12.x/migrations#column-method-uuidMorphs>
che crea due colonne. I tre sistemi per uuid sono;

* $table->uuid(campo)
  crea la colonna formato char(36), non necessariamente una pk.  
* $table->foreignUuid(campo)
  crea la colonna formato uuid indicando anche che c'è una pk in un'altra tabella,
  e se uno è interessato mette il nome della tabella (al singolare) nel nme del campo.  
  *foreignUuid('user_id') -> users.id*
* $table->uuidMorphs(campo)  
  crea 2 colonne: la colonna campo_id char(36) e una colonna campo_type varchar
  e serve per la gestione delle relazioni tra tabelle gestita da Eloquent.

Quello che mi chiedo è quanto vantaggio ci sia a usare una formula  
$contact = User::find( *user_id* )->contact;  
piuttosto di  
$contact = UserContact::where('user_id', *user_id* )->get();

La seconda sembra più grezza ma la prima è più *laravel style*. E comunque
in una tabella che è per sua natura relazione tra tabelle, come quella
delle opere partecipanti, per trovare nome concorso, nome sezione,
nome partecipante e titolo opera devo fare 4 query separate.

### Tabelle di vocabolari

Quando un campo può avere un limitato set di valori, dal binario [ 'N', 'Y']
è consigliato usare una tabella di appoggio per contenere il set do valori
e abbinarla. Questo di fatto sostituisce una gestione degli ENUM dalla tabella.

Però volendo adottare questo approccio, non posso nominare le tabelle di appoggio alla cazzicanista,
serve un formato di nome che chiarisca il ruolo di appoggio, e la tabella+campo.

* contest_participants contiene il campo fee_payment_completed che assume un set limitato
* `contest_participants_fee_payment_completed_set` sarà il nome della tabella

[Creare la tabella con il legame in laravel](https://laravel.com/docs/12.x/migrations#foreign-key-constraints)

Prima va creata la tabella set poi la tabella che con set ha un legame.
Caricata la tabella con Y N

Applico la regola ai ruoli degli utenti

### User_roles.role

```php
$ php artisan make:migration create_user_roles_role_set

   INFO  Migration [database/migrations/2025_10_10_112237_create_user_roles_role_set.php] created successfully.  

$ php artisan make:factory UserRolesRoleSetFactory

   INFO  Factory [database/factories/UserRolesRoleSetFactory.php] created successfully.  

$ php artisan make:seeder UserRolesRoleSetSeeder

   INFO  Seeder [database/seeders/UserRolesRoleSetSeeder.php] created successfully.  
```

Creo la tabella, e la carico con i ruoli (voci in inglese), poi creo il legame con la tabella user_roles
e poi sfilo i rifermenti dal Model, via l'array di valid.

A questo punto se levo anche l'array valid_roles, devo sostituirlo con una funzione statica
che restituisce lo stesso set di valori, c'è una s di meno e piuttosto che cancellare tutto
uso la funzione di rinomina tabelle.

### la s

`Schema::rename('user_roles_role_set', 'user_roles_role_sets');`  

