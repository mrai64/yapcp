# Diario dello sviluppatore, data 10 ottobre 2025

* [index](../index.md)
* [TDL](../TDL.md)
* [project](https://github.com/users/mrai64/projects/1)
* [‚óÄÔ∏è ieri](./2025-10-09_IT.md)
* [log](/storage/logs/laravel.log)

## Prossimo step

### Reformat tabelle contest_works (nuova) e contest_participants

Creata la tabella contest_participants, versione 2. Creare in automatico dei
concorsi comporta un sacco di lavoro. Sistemare il Model, creare le pagine per Participant List.
Se lo user_id in linea Auth::id() ha uno user_role() nel concorso pu√≤
cambiare lo stato della quota di iscrizione "da pagare" a "pagato" con un click.

Nella Participant List devono anche essere elencate a parte le sezioni del concorso
e quante opere per ciascun partecipante sono iscritte a concorso.

Malsana idea: non aggiungere la colonna pagamento. Primo perch√© serve qualcosa che
decida in automatico la quota da versare, e pu√≤ essere una quota fissa per autore,
una quota fissa per autore diversa se usa un codice sconto, una quota diversificata
se partecipa in due o pi√π sezioni. Si far√† ma non √® un obiettivo urgente.

## Studiare: Relazioni tra tabelle [vedi](https://laravel.com/docs/12.x/eloquent-relationships)

Passando la malsana idea del pagamento sono andato a vedere quali
siano i *tipi* di campi previsti oltre al float che consentono i decimali.
Nessuno, nemmeno un unsignedFloat. Allo stesso tempo ho trovato dei tipi
uuidMorph ulidMorph che hanno attratto la mia attenzione. In qualche modo
si vuole anticipare al sistema che ci sono campi uuid in relazione tra tabelle.
Sono anche previsti dei metodi dedicati *hasOne*, *belongsTo*
A me non mancano tabelle correlate ma questo sistema di indicazioni che applicazione ha?
Velocizza le ricerche? Per esempio in molte tabelle devo estrarre dei dati basandomi su uuid,
che banalmente possono essere nome, cognome di uno user uuid, il nome del concorso con il suo uuid
e cos√¨ via.

Users e User_Contacts, relazione 1:1
In questo caso users √® la registrazione di email e password per accedere al sistema che
√® separata dalla gestione dei dati anagrafici e di contatto, ma c'√® una relazione 1:1
Quindi posso definire nella classe User HasOne() e ottenere la class UserContac

```php
public function contact(): HasOne
{
  return $this->hasOne(UserContact::class);
}

// e ottenere la scheda con un semplice
  $contact = User::find( 'a1b2c3-...' )->contact;
```

Quando i nomi delle colonne consentono un facile abbinamento, *users.id <-> user_contacts.user_id*  
I campi nella migration li ho definiti come foreignUuid, ma esiste anche un'altra definizione
<https://laravel.com/docs/12.x/migrations#column-method-uuidMorphs>
che crea due colonne. I tre sistemi per uuid sono;

* $table->uuid(campo)
  crea la colonna formato char(36), non necessariamente una pk.  
* $table->foreignUuid(campo)
  crea la colonna formato uuid indicando anche che c'√® una pk in un'altra tabella,
  e se uno √® interessato mette il nome della tabella (al singolare) nel nme del campo.  
  *foreignUuid('user_id') -> users.id*
* $table->uuidMorphs(campo)  
  crea 2 colonne: la colonna campo_id char(36) e una colonna campo_type varchar
  e serve per la gestione delle relazioni tra tabelle gestita da Eloquent.

Quello che mi chiedo √® quanto vantaggio ci sia a usare una formula  
$contact = User::find( *user_id* )->contact;  
piuttosto di  
$contact = UserContact::where('user_id', *user_id* )->get();

La seconda sembra pi√π grezza ma la prima √® pi√π *laravel style*. E comunque
in una tabella che √® per sua natura relazione tra tabelle, come quella
delle opere partecipanti, per trovare nome concorso, nome sezione,
nome partecipante e titolo opera devo fare 4 query separate.

### Tabelle di vocabolari

Quando un campo pu√≤ avere un limitato set di valori, dal binario [ 'N', 'Y']
√® consigliato usare una tabella di appoggio per contenere il set do valori
e abbinarla. Questo di fatto sostituisce una gestione degli ENUM dalla tabella.

Per√≤ volendo adottare questo approccio, non posso nominare le tabelle di appoggio alla cazzicanista,
serve un formato di nome che chiarisca il ruolo di appoggio, e la tabella+campo.

* contest_participants contiene il campo fee_payment_completed che assume un set limitato
* `contest_participants_fee_payment_completed_set` sar√† il nome della tabella

[Creare la tabella con il legame in laravel](https://laravel.com/docs/12.x/migrations#foreign-key-constraints)

Prima va creata la tabella set poi la tabella che con set ha un legame.
Caricata la tabella con Y N

Applico la regola ai ruoli degli utenti

### User_roles.role

```php
$ php artisan make:migration create_user_roles_role_set

   INFO  Migration [database/migrations/2025_10_10_112237_create_user_roles_role_set.php] created successfully.  

$ php artisan make:factory UserRolesRoleSetFactory

   INFO  Factory [database/factories/UserRolesRoleSetFactory.php] created successfully.  

$ php artisan make:seeder UserRolesRoleSetSeeder

   INFO  Seeder [database/seeders/UserRolesRoleSetSeeder.php] created successfully.  
```

Creo la tabella, e la carico con i ruoli (voci in inglese), poi creo il legame con la tabella user_roles
e poi sfilo i rifermenti dal Model, via l'array di valid.

A questo punto se levo anche l'array valid_roles, devo sostituirlo con una funzione statica
che restituisce lo stesso set di valori, c'√® una s di meno e piuttosto che cancellare tutto
uso la funzione di rinomina tabelle.

### la s

`Schema::rename('user_roles_role_set', 'user_roles_role_sets');`  

### Lista dei partecipanti

C'√® una lista partecipanti che deve essere accessible a tutti,

```php
$ php artisan livewire:make Contest/Participants/Listed
 COMPONENT CREATED  ü§ô

CLASS: app/Livewire/Contest/Participants/Listed.php
VIEW:  resources/views/livewire/contest/participants/listed.blade.php
```

Caricati un tot di utenti, con nessuna foto in concorso, funziona **commit**

### Lista dei partecipanti (2)

A questo punto serve rifare tutto, per un'altra funzione. La prima lista dei partecipanti
√® fornita in lettura a tutti. Questa seconda deve - come per il caricamento delle opere a concorso -
consentire per gni record / partecipante di aggiornare da N a Y e da Y a N il valore del
pagamento effettuato. La pagina deve essere raggiungibile non solo da un utente registrato
e verificato, ma da un utente tra quelli dell'ente organizzatore, o che abbia un incarico nel concorso.
Per esempio *chairman*.
A questo punto va anche aggiunto un ulteriore record: chi √® l'utente che fa la modifica.
Per non avere l'effetto "tutti in un colpo" devo creare un componente
per ogni record. Questo componente ha tutti campi wire.fill="" e solo un wire.live.defer=""

####¬†Middleware per le abilitazioni

L'utente deve essere:
* registrato
* verificato
* presente nella tabella user_roles
  con legame al concorso
