# Diario dello sviluppatore, data 2 ottobre 2025

* [index](../index.md)
* [TDL](../TDL.md)
* [log](/storage/logs/laravel.log)
* [project](https://github.com/users/mrai64/projects/1)
* [‚óÄÔ∏è ieri](./2025-10-01_IT.md)

## iscrizione opere a concorso

La pagina si presenter√† con una barra di navigazione che elenca le sezioni,
solo sigla e il numero di opere assegnate, seguito da info da definire.
elenco opere con link al caricamento di nuove opere.
elenco opere ordinato per ? data di caricamento desc. oppure titolo asc.
affianco alle opere campo select con valore questa no/sezione.
L'elenco dovrebbe cambiare quando si raggiunge il limite di caricamento
per la sezione la sezione dovrebbe sparire.
A sinistra delle opere il campo di selezione, a destra delle opere
informazioni sulle stesse come: titolo, dimensioni, formato,
sarebbe utile anche un semaforo verde/rosso per indicare quando
le opere non sono conformi.

* tabella delle partecipazioni, contest_? contest_works? contest_participants?

## Contest_participants

La tabella elenca i concorsi, le sezioni, gli user, le opere,
un campo per segnare se l'opera √® stata ammessa a concorso (Y/N),
un campo per gl eventuali award ricevuti. Questo no, gli award
andranno registrati nella tabella degli award, dove
sar√† riportata una coppia di colonne works.id e user_contact.user_id.  
E ci avevo gi√† pensato. Tre colonne per i premiati, opere user e gruppi.  

```php
$ php artisan make:migration create_contest_participants_table

   INFO  Migration [database/migrations/2025_10_02_081413_create_contest_participants_table.php] created successfully.  

$ php artisan make:model ContestParticipant

   INFO  Model [app/Models/ContestParticipant.php] created successfully.  

$ php artisan livewire:make Contest/Subscribe
 COMPONENT CREATED  ü§ô

CLASS: app/Livewire/Contest/Subscribe.php
VIEW:  resources/views/livewire/contest/subscribe.blade.php
```

Avanzamento lavori:
Tutto apparentemente regolare fino a quando non inizio a interagire con il form.
Di fatto la tabella dei lavori ha un form per ogni lavoro, e sono tutti uguali.
Quindi quando cambio un select, si aggiornano tutti, perch√© tutti sono allo stesso tempo
legati allo stesso campo. Si pu√≤ fare un "form array"?

Una richiesta alla A dice che √® prassi incasinarsi per questo, e propone
due soluzioni: una √® quella di trasformare il form della riga di tabella in un componente
livewire per conto suo con il suo controller, cos√¨ sono tutti indipendenti.
L'altra √® indicizzare gli elementi della tabella e usare l'indice per comporre i name
dei campi che quindi diventano tutti distinti. Mi sembra pi√π semplice la prima proposta, quella del componente livewire per ciascun form.

E qui viene un altro problema: non si possono passare due parametri,  
Livewire only supports one HTML element per component. Multiple root elements detected for component: [contest.subscribe.add]  
Invece di passare la contest_selection_list, che √® grossa, posso passare solo il contest_d e il work_id che sono due stringhe di 36 byte, creando una stringa csv.
contest_id,work_id. Nel componente mi creo e uso la contest_section_list.

[Suggerimento 1](./2025-10-02%20alle%2021.16.08.png)  
[Suggerimento 2](./2025-10-02%20alle%2021.16.22.png)  

### ENUM, suggerimenti

Gi√† sostituito da un array in qualche caso, il suggerimento
√® quello di farlo diventare sempre una tabella esterna con legame tra colonne.
In questo modo non si pu√≤ eliminare un elemento dalla tabella elenco
se ci sono elementi che usano la chiave, e si possono aggiungere
elementi se servono. Caso a parte Y/N? No, anche per quelli va fatta una
tabella a parte, per√≤ si devono fare metodi statici per la lettura dei dati.
Magari non vanno fatte pagine dedicate per cambiare e aggiungere dati,
che si possono fare direttamente nel db.

### A proposito di ENUM

Man mano che vado avanti vedo il rovescio della medaglia di usare uuid,
ovvero che il codice obbliga a fare dei passaggi aggiuntivi quando si vuole
avere un elenco sortato per qualcosa tipo cognome e nome.
Devo quindi organizzare delle viste?

### Eventi

C'√® chi avvia/scatena eventi e chi li ascolta. i Listener fanno delle cose:

* chi ascolta e aggiorna il numero di lavori per sezione +1 -1
* chi segnala che si sono aggiunti / tolti lavori
* chi ascolta che si sono aggiunti / tolti lavori e li aggiunge/toglie alla tabella

Riprendo il corso Edoardo Midali | [20. A chiamata rispondo. Pronti, eventi via!](https://youtu.be/pEUKVz-sWYI?si=Z1Xb2sWy7HNftwDP)

* create Event ContestParticipationAdd(Contestparticipant $participant)  
Questo quando √® richiamato crea l'evento e lo distribuisce in un canale
* create Listener CounterContestAdd()  
Questo ascolta e reagisce - ma come fa?
A me viene in mente di creare una variabile SESSION che parte da 0
e viene incrementata, questa variabile session
* create ServiceProvider
Questo dice al sistema dal boot() che deve attivare il Listener

## LIVEWIRE v.2 > v.3

Fatto un aggiornamento e scassato il sistema, chiede se deve spostare un sacco di componenti e poi una volta che uno ha dato ok a tutto pare non trovi un component.component.qualcosa, butto tutto e faccio ripristino da time machine, prima risolvo la gestione dei form, poi quando √® a posto si vedr√†.
