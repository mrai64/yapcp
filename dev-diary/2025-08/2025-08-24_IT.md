# Diario dello sviluppatore, Ep.21. data 24 agosto 2025

Nav: [index](../index.md) : [TDL](../TDL.md) : [log](../../storage/logs/laravel.log)

## Errori non segnalati

Sui tutorial tutto fila liscio e tutto sembra semplice,
e poi fai un modulo che non funziona e non ti espone nemmeno
un messaggio di errore,... Quindi? quindi dopo aver controllato che
tutto **sembra ma non è** a posto fai il passo del gambero.

Quello che per cominciare no funziona sembra la convalida del campo `code`, anche se lo riempio mi torna un messaggio di campo necessario.

PS [convalida in laravel](https://laravel.com/docs/12.x/validation#form-request-validation)

Attualmente parte, fa il suo giro e torna al punto iniziale senza fare inserimento e senza dare messaggi di errore.

**Risolto** seguendo le indicazioni base di [livewire doc](https://livewire.laravel.com/docs/wire-model)

- nel campo `wire:model` proprietà
- nel form `wire:submit` funzione

E adesso **commit**.

### Modifica

1. Creare component modifica Federation
1. Aggiungere route per mod
1. Aggiungere link MOD pulsante all'elenco delle Federation
1. collaudare la modifica live

Già che creo la componente ModifyFederation creo per uso futuro anche le componenti Federation/Add (~~Federation/List~~ non si può, Class List è riservato) Federation/Listed (ok si può), Federation/Add (~~Federation/New~~ New è riservato).
L'idea è che dopo aver fatto il giro per secondo livello sistemare ogni cosa nei componenti dedicati alle federation. per avere più ordine quando ci saranno più e più elementi.  
Non so se per le tabelle child valga la penda di fare delle componenti all'interno delle cartelle delle tabelle father. Sarebbe interessante confrontarsi con qualcuno che lo ha già fatto.

Richiesta community italiana

- il parametro id deve passare 'id' in route() e venire
  richiamato come $id in mount() nel component

Funziona, e adesso **commit**

### Lista, Aggiungi, Aggiorna, manca: Cancella

Quarta funzione dell'acronimo CRUD, create read update DELETE.
Decido di utilizzare la funzione softDelete prevista
da laravel, per un motivo preciso: la cancellazione fisica
non ammette ripensamenti. Quando il record è tolto l'unica
cosa che si può fare per rimediare è inserirne uno nuovo
con gli stessi dati di quello eliminato. Al lavoro vecchio
il cliente banca si era pensato invece di fare una tabella
a parte, chiamata tabella specchio *mirror*, in cui caricare
il record che veniva cancellato dalla tabella principale.
La tabella mirror aveva le stesse colonne e degli indici
diversi, questo consentiva in seguito di passare i dati,
anche milioni di record, a un altro sistema battezzato
Data Lake in cui si poteva seguire la vita di un record
dalla create alla update alla delete. In questa piattaforma
invece la cosa è un po' più semplice: i campi created_at,
updated_at, delete_at - che non saranno timestamp ma datetime -
servono per una futura funzione di backup e successiva
pulizia. Si vuole vincolare il backup a un datetime
che sarà memorizzato in un file `.backup-from`, con valore
iniziale `0001-01-01 00:00:01`, e si farà il backup
incrementale di tutto quello che ha `update_at >= backup_from`
e la cancellazione fisica di tutto quello che ha
`deleted_at != null && deleted_at < backup_from`, seguito
a bon fine dall'aggiornamento del backup_from con il datetime
di inizio operazioni, non quello di fine.

1. ✅ Creare la colonna deleted_at come datetime
1. ✅ Cambiare le colonne timestamp in datetime
1. ✅ Cambiare il Model Federation
1. ✅ Refresh della tabella
1. ✅ Ricarico della tabella con una ventina di record
1. ⬜️ Creare quello che serve per la cancellazione del record
nella lista delle federation

Per l'ultimo step procedo come fosse un modify, solo che in mezzo non ci sarà un modulo modificabile, tutti i campi saranno readonly. Si può anche procedere "in diretta", ma questa strada più lunga è anche un modo per inserire un
punto di `Confermi?`

```php
php artisan livewire:make DeleteFederation

CLASS: app/Livewire/DeleteFederation.php
VIEW:  resources/views/livewire/delete-federation.blade.php
```

Per il modulo mi sono serviti due route, una che fa la get del modulo
e fornisce i dati da esporre, la seconda alla confirm con method="DELETE"
va a chiamare la funzione e cancella il record, tornando alla lista delle
Federation.

Funziona, testato! **commit**!
