# Chiedi a Gemini del 5 febbraio 2026

## Domanda 1

Laravel casts(), nel caso di un campo booleano memorizzato in database come 0/1 posso inserire 'is_active' => 'boolean' ma posso farlo anche se il campo contiene Y/N o devo impostare 'string'? oppure 'char(1)'?

## Risposta 1

Se il tuo database memorizza un campo booleano come `0` o `1` (il default di MySQL per i tipi `TINYINT(1)`), il cast `'boolean'` funziona perfettamente in modo nativo.

Tuttavia, se il campo contiene **'Y'** o **'N'**, il cast `'boolean'` **non funzionerà correttamente** in fase di scrittura, perché Laravel tenterà di passare al database un valore booleano reale (true/false) o un intero, e non le stringhe 'Y' o 'N'.

Ecco le soluzioni possibili per gestire il caso 'Y'/'N':

### 1. La soluzione moderna: Attribute Mutator (Consigliata)

Invece di usare `casts()`, definisci un Mutator/Accessor nel modello. Questo ti permette di mappare 'Y'/'N' direttamente sui booleani di PHP (`true`/`false`) in modo trasparente.

```php
use Illuminate\Database\Eloquent\Casts\Attribute;

protected function isActive(): Attribute
{
    return Attribute::make(
        // Quando leggi dal DB: converte 'Y' in true, tutto il resto in false
        get: fn (string $value) => $value === 'Y',
        
        // Quando scrivi nel DB: converte true in 'Y', false in 'N'
        set: fn (bool $value) => $value ? 'Y' : 'N',
    );
}

```

### 2. La soluzione classica: Custom Casts

Se hai molti campi 'Y'/'N' in diverse tabelle, puoi creare una classe di cast personalizzata per non ripetere il codice.

```php
// Crea una classe: app/Casts/YesNoBoolean.php
namespace App\Casts;

use Illuminate\Contracts\Database\Eloquent\CastsAttributes;
use Illuminate\Database\Eloquent\Model;

class YesNoBoolean implements CastsAttributes
{
    public function get(Model $model, string $key, mixed $value, array $attributes): bool
    {
        return $value === 'Y';
    }

    public function set(Model $model, string $key, mixed $value, array $attributes): string
    {
        return $value ? 'Y' : 'N';
    }
}

// Nel tuo Modello:
protected function casts(): array
{
    return [
        'is_active' => \App\Casts\YesNoBoolean::class,
    ];
}

```

### Perché non usare `'string'` o `'char(1)'`?

Se imposti il cast a `'string'`, Laravel ti restituirà letteralmente la stringa `"Y"`. Questo ti costringerebbe a scrivere ogni volta dei controlli scomodi nel codice, come:
`if ($user->is_active === 'Y')`

Usando le soluzioni sopra, invece, potrai continuare a scrivere codice pulito:
`if ($user->is_active)` (perché Laravel lo avrà già trasformato in un vero `true`).

**In sintesi:** Se hai 'Y'/'N', non usare il cast `boolean` predefinito, ma usa un **Attribute Mutator** (soluzione 1) per mantenere il tuo codice elegante e "PHP-friendly".
