# 19/02/2026

[⏪ ieri](./2026-02-17_IT.md) | [index](../index.md) | [domani ⏩](./2026-02-20_IT.md)  
[Docs](/resources/docs/1.0/overview.md)

## Nuova tabella in arrivo

Salto un giorno e mi sembra passato un mese.
Sto nel mezzo di una modifica strutturale che prevede
di avere due tabelle gemelle che hanno
due pk identiche per struttura e contenuto.
Quindi users viene dedicata al solo ingresso in piattaforma
e user_contacts a tutti i dati anagrafici, postali e di contatto.

E si affaccia un'altra modifica strutturale.
Nel mainframe c'è il [RACF](https://en.wikipedia.org/wiki/Resource_Access_Control_Facility), a me serve più semplicemente
una tabella in cui in base a un gruppo di appartenenza
si possono / non possono accedere delle view.
Anche qui la scelta c'è: posso decidere se
abilitare l'operazione crud, posso scegliere
se bloccare la view. O entrambe.  
Gemini ha indicato che pacchetti come quello di spatie
non hanno la granularità che serve a me ma
dice che lavorano "sul globale".

* id record che non manca mai
* colonna identificativa del gruppo  
Qui si crea una tabella lookup dedicata
* colonna identificativa della view  
Qui si mette il name() che è inserito nella route

Sarà certamente una tabella ad alto numero di accessi
per cui devo capire se la funzione di cache mi può aiutare.
L'ottimo sarebbe averla in memoria perché è di fatto
una tabella con pochi aggiornamenti.

Le view di lettura e modifica della tabella stessa
sarebbero ristrette al gruppo admin.

L'altra versione riguarda le operazioni sui Model/tabelle
e quindi in base alle operazioni CRUD a cui vanno aggiunte
List Backup e Restore io potrei abilitare il gruppo guest
a fare le list, e all'opposto il gruppo admin a fare tutto.

Nomi per le tabelle:  
~~user_matrix_views~~ `user_group_acm_views`  
~~user_matrix_models~~ `user_group_acm_models`  

User_group e non solo user, lasciare solo user fa pensare
che l'id sia user_contacts.id invece sarà uan stringa ascii.
`User_group_sets` potrebbe essere la tabella
di lookup.

## La gestione del progetto

Mi pare chiaro che devo continuare a lavorare sul pezzo altrimenti
perdo il flo del dove eravamo, quindi devo trovare
un sistema per quanto basico di gestione progetto
perché qui ho dei pezzi ma non la mappa dall'alto.
C'è in github una lista di issue che sostituisce
la To Do List, ho visto come creare le discussion
che potrebbero sostituire almeno formalmente
la lista di issue che alla fin fine sono chiamati
problemi.
Ho anche uno spazio docs in cui dovrebbe entrare
la manualistica
Ho anche ricreato le migrations e sistemato qualche
factory/seeder per le tabelle di lookup
Ho imparato benedetto il Ctrl+t che mi inverte le lettere
da pu a up.

Sono tutti pezzi della gestione, manca la gestione dei pezzi.

## Miniature

Si tratta di gestire le miniature dei partecipanti
e quindi prevedere un metodo nella classe UserWork,
e lo stesso per le immagini partecipanti al concorso
e quindi nella classe ContestWork.

Ma c'è un problema. Dev'essere passato almeno
il path e nomefile dell'originale, quindi non dovrebbe
essere una funzione statica.

la funzione miniature è definita in almeno 5 sorgenti,
praticamente nella stessa versione.

Prima finisco il giro delle modifiche per PSR-12 e user_contacts.user_id
