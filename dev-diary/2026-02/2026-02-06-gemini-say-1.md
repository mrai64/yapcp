# Chiedi a Gemini del 6 febbraio 2026

## Domanda 1

Nel progetto https://github.com/mrai64/yapcp sto imparando laravel, e un po' per volta aggiungo cose che mancano e dovrebbero esserci. Si tratta di una piattaforma per gestire concorsi fotografici, con utenti, concorrenti, giurati, organizzatori e però sto sviluppando e testando man mano i vari pezzi del codice. Ho messo su phpStan, Pint, e però mancano del tutto i "test automatici". cosa sono e come li realizzo da zero?

## Risposta 1

Ottima iniziativa! Aggiungere test automatici a un progetto come **yapcp** (Yet Another Photo Contest Platform) è il salto di qualità definitivo: ti permette di modificare il codice senza la paura costante di aver rotto qualcosa (la cosiddetta "regressione").

### Cosa sono i Test Automatici?

In parole povere, sono **script che verificano che il tuo codice faccia quello che ti aspetti**. Invece di aprire il browser e cliccare manualmente su "Invia" per vedere se il form delle foto funziona, lanci un comando e il computer lo controlla per te in pochi millisecondi.

In Laravel, i test si dividono principalmente in due categorie:

1. **Unit Test:** Testano una singola funzione o una piccola logica isolata (es. "Il calcolo della media voti di una foto è corretto?").
2. **Feature Test:** Testano un'intera funzionalità simulando una richiesta HTTP (es. "Se un utente non loggato prova a votare, riceve un errore 403?").

---

### 1. Preparazione dell'ambiente

Laravel è già configurato per i test. Trovi tutto nella cartella `/tests`.

* **Configurazione:** Controlla il file `phpunit.xml`. Di default, Laravel usa **SQLite** in memoria per i test, il che è perfetto perché è velocissimo e non sporca il tuo database reale.
* **Database:** Assicurati che queste righe siano presenti nel `phpunit.xml` (o nel `.env.testing`):
```xml
<env name="DB_CONNECTION" value="sqlite"/>
<env name="DB_DATABASE" value=":memory:"/>

```



---

### 2. Creare il tuo primo test

Immaginiamo di voler testare che la pagina dei concorsi sia accessibile. Esegui nel terminale:

```bash
php artisan make:test CompetitionTest

```

Questo creerà un file in `tests/Feature/CompetitionTest.php`. Aprilo e scrivi:

```php
public function test_homepage_competitions_is_accessible(): void
{
    // Eseguiamo una chiamata GET alla rotta dei concorsi
    $response = $this->get('/competitions');

    // Verifichiamo che il server risponda con codice 200 (OK)
    $response->assertStatus(200);
}

```

---

### 3. Testare la logica (Esempio: Caricamento Foto)

Per un concorso fotografico, il test più importante è quello del caricamento. Ecco come appare un test che simula un utente:

```php
public function test_user_can_upload_photo(): void
{
    // 1. Creiamo un utente "finto" usando le Factory
    $user = User::factory()->create();

    // 2. Simuliamo il login e l'invio di un file
    $response = $this->actingAs($user)
        ->post('/photos/upload', [
            'title' => 'Tramonto bellissimo',
            'image' => UploadedFile::fake()->image('photo.jpg')
        ]);

    // 3. Verifichiamo il risultato
    $response->assertRedirect('/dashboard');
    $this->assertDatabaseHas('photos', ['title' => 'Tramonto bellissimo']);
}

```

---

### 4. Come eseguire i test

Una volta scritti, ti basta lanciare:

```bash
php artisan test

```

Vedrai una lista verde (se passano) o rossa (se falliscono). Visto che usi già **Pint** e **PHPStan**, l'esecuzione dei test è il terzo pilastro per una CI/CD (Continuous Integration) solida.

---

### Gli strumenti "Must-Have"

Per procedere spedito, ti consiglio di approfondire questi due concetti:

| Strumento | Scopo |
| --- | --- |
| **Factories** | Generano dati finti nel database (es. `Competition::factory()->create()`). Indispensabili per non creare i dati a mano in ogni test. |
| **RefreshDatabase** | Un "Trait" da aggiungere ai tuoi test per pulire il database dopo ogni singola esecuzione, garantendo che i test siano indipendenti. |

### Prossimo passo consigliato

Il tuo progetto ha diversi ruoli (Giurati, Organizzatori). Sarebbe molto utile creare un test che verifichi che **un Giurato non possa eliminare un concorso**, mentre un Organizzatore sì.

**Vuoi che proviamo a scrivere insieme un test specifico per la gestione dei ruoli (ACL) del tuo progetto?**

## Domanda 2 

Preferirei cominciare con qualcosa di più basico, tipo verificare che uno si può iscrivere, che può modificare la sua scheda personale, che può inserire una organizzazone e via via quello che viene fatto ma parto proprio da zero.

## Risposta 2

Ottimo approccio. Partire dalle basi (il cosiddetto "percorso felice" o *happy path*) è il modo migliore per non scoraggiarsi. In Laravel, per testare queste azioni, useremo i **Feature Tests** perché simulano esattamente ciò che un utente fa nel browser.

Per prima cosa, assicurati che nei tuoi test sia presente il trait `RefreshDatabase`. Questo svuota il database ogni volta che lanci un test, così i dati non si accumulano.

### 1. Test di Iscrizione (Registration)

Vogliamo verificare che un utente possa compilare il form, che venga salvato nel database e che venga loggato.

```php
// tests/Feature/RegistrationTest.php

use Illuminate\Foundation\Testing\RefreshDatabase;
use Tests\TestCase;

class RegistrationTest extends TestCase
{
    use RefreshDatabase; // Fondamentale!

    public function test_new_users_can_register(): void
    {
        $response = $this->post('/register', [
            'name' => 'Mario Rossi',
            'email' => 'mario@example.com',
            'password' => 'password123',
            'password_confirmation' => 'password123',
        ]);

        // Verifica che l'utente sia stato creato nel DB
        $this->assertDatabaseHas('users', [
            'email' => 'mario@example.com',
        ]);

        // Verifica che dopo la registrazione l'utente sia loggato e reindirizzato
        $this->assertAuthenticated();
        $response->assertRedirect('/home'); 
    }
}

```

---

### 2. Modifica del Profilo (Update Profile)

Qui dobbiamo testare che un utente **loggato** possa cambiare i suoi dati, ma che un utente **non loggato** non possa farlo.

```php
public function test_user_can_update_profile_info(): void
{
    // Creiamo un utente esistente
    $user = \App\Models\User::factory()->create();

    // Ci identifichiamo come quell'utente e inviamo la modifica
    $response = $this->actingAs($user)
        ->patch('/profile', [
            'name' => 'Nuovo Nome',
            'email' => 'nuovo@example.com',
        ]);

    // Verifichiamo il cambio nel database
    $this->assertDatabaseHas('users', [
        'id' => $user->id,
        'name' => 'Nuovo Nome'
    ]);
}

```

---

### 3. Creazione di un'Organizzazione

In **yapcp**, un organizzatore deve poter inserire la sua realtà. Questo test verifica che la logica "Crea Organizzazione" funzioni.

```php
public function test_organizer_can_create_organization(): void
{
    $user = \App\Models\User::factory()->create();

    $response = $this->actingAs($user)
        ->post('/organizations', [
            'name' => 'Fotoclub Alpha',
            'description' => 'Un circolo di appassionati',
            'website' => 'https://alpha.test',
        ]);

    $this->assertDatabaseHas('organizations', [
        'name' => 'Fotoclub Alpha'
    ]);
}

```

---

### Come ragiona un test? (Il ciclo AAA)

Per scrivere bene i test, segui sempre questo schema mentale:

1. **Arrange (Prepara):** Crea gli utenti, i dati iniziali o lo stato del database (es. `User::factory()->create()`).
2. **Act (Agisci):** Esegui l'azione principale (es. `$this->post(...)`).
3. **Assert (Verifica):** Controlla se il risultato è quello sperato (es. `$this->assertDatabaseHas(...)`).

### Un consiglio pratico per yapcp

Visto che stai imparando, ti consiglio di installare anche **Laravel Telescope** (se non l'hai già fatto) in ambiente locale. Ti permette di vedere esattamente cosa succede "sotto il cofano" (query, mail inviate, eccezioni) quando un test fallisce.

**Ti va se proviamo a creare una "Factory" per il modello Organization?** È il file necessario per generare organizzazioni finte nei tuoi test con una sola riga di codice.

