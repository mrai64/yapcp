# 11/02/2026

[⏪ ieri](./2026-02-10_IT.md) | [index](../index.md) | [domani ⏩](./2026-02-12_IT.md)  
[Docs](/resources/docs/1.0/overview.md)

## Refactor

Migration su yapcp4 e rilanciate lì. Aggiustamenti
Con il sito <https://www.drawdb.app/editor>  

* esportazione mysqldump della struttura
* importazione mysql del file
* esportazione md [doc](./2026-02-11T10_45_30.622Z.md)

**PROBLEMA** NON SI VEDONO TUTTE LE RELAZIONI. Che ci sono.

### 1. Model refactor

Occorre ripassare i Model per verificare che tutti i migration con uuid
  siano associati a model con HasUuids.

**I moduli generati** non vanno a bloccare le funzioni dei modelli,
ma sono uno strumento per fare le cose "alla laravel", quindi
entrando nella logica della piattaforma Laravel per godere dei vantaggi.

* **UserContact**  
  *Evvai!*, già alla prima HasUuids mancava, ma c'è una giusta:
  questo ha sempre avuto *id* standard, ignorato perché la vera pk
  era user_contacts.user_id == users.id  
  *Next stop*: user_id quando sarà uguale a id viene segata.  

Altro problema: attualmente quando un utente si registra
  parte in inserimento sql users e con un trigger inserisce
  anche il record user_contacts. il seeder di users diventa
  paro paro quelli di user_contacts. Quindi il seeder di
  user contacts ora contiene un loop che va a scrivere i record di
  user_contacts che mancano nella tabella ma tecnicamente
  non ne dovrebbe mancare nessuno. E poi se viene inserito
  un record in user_contacts manca in users.

Per fare una cosa pulita
  devo smontare il trigger che crea user_contacts,
  e anche quello che alla modifica del campo email in user_contacts
  va a ribaltare la modifica in users.email.  

Essendo una tabella in legame 1:1 posso usare uuid come pk
e generare user_contacts.id = users.id. Si può fare 
Devono diventare parti del modello di aggiornamento.
  Come quando viene creato User e parte una notifica per mandare,
  anzi no: parte una dispatch che avvisa dell'inserimento new User,
  e ci sarà un listener che prepara e invia la notifica.
Ci sarà anche un dispatch per la modifica dell'indirizzo email
  e un listener che andrà a prendere e aggiornare l'email
  in Users se va aggiornata.

### 2. Factory e Seeder refactor

Occorre verificare factory e seeders per le lookup table

* Region
* Timezone
* Country
* User
* UserContact
* Federation
* FederationSection
* FederationMore
* UserMore
* Organization
* UserRoleRoleSet
* UserRoleContextSet
* UserRole
