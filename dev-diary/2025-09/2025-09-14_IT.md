# Diario dello sviluppatore, data 14 settembre 2025

Nav: [index](../index.md) : [TDL](../TDL.md) : [log](../../storage/logs/laravel.log)

## Mandare una mail post-login / segue

Stamattina ho chiesto aiuto nel [canale telegram dei Laravelliani](https://web.telegram.org/a/#-1001268897006),
e ho fatto bene perché anche se scettico ho applicato il suggerimento
ed è andato a buon fine. Avevo (c'è tutto rintracciabile su github,
non posso dir bugie e farla franca) impostato una istanza a vuoto di user per richiamare
il notify del model User, passandogli comunque una istanza del form
che contiene l'indirizzo email. Ma non funzionava e cambiando l'istanza passante
con quello user che si è appena collegato, visto che email è campo
non ripetibile in tabella uno ne trova, è andato tutto liscio.

funziona, **commit**

Visto che per chiedere aiuto ho creato un branch, adesso il branch
lo lascio aperto per un po' ma ho già fatto il **pull request** e
il **merge** con il branch main.

## new o New?

Nella lista mi suggeriscono di non usare `New`, ma `new`
che è operatore e va in minuscolo.
Non lo rileva come errore l'editor, ma obbedisco, in fondo s'impara.
Escludo dalla ricerca alcuni file p.es. quello delle nazioni con
*Papua New Guinea*. Aggiornamento cumulativo e **commit**

## Contest/Section

Dopo aver definito la parte del concorso che è comune a tutti i concorsi,
lo step successivo può essere definire le sezioni e temi per cui si concorre.  
L'idea che ho è che dopo la pagina di "aggiungi concorso"
si passi a una pagina per l'aggiunta delle sezioni. In questa pagina
venga riportato nella parte di intestazione l'insieme di alcuni dati
del concorso, con il suo pulsante di modifica che fa tornare alla scheda principale,
seguita da un elenco di sezioni già presenti (inizialmente vuoto)
seguita da un form per l'aggiunta della sezione. Un pulsante di aggiungi
nuova sezione e un pulsante di inserimento completato, alla prossima pagina.
Ogni sezione già inserita avrebbe il suo pulsante di modifica, se si sono
inseriti refusi o si vuole cambiare l'elenco.

[Model](/app/Models/ContestSection.php)  
[migration](/database/migrations/2025_09_14_150105_create_contest_sections_table.php)  

Campi della tabella sezioni dei concorsi  

* id  
come pk id va bene anche un id numerico incrementale progressivo? Da pensarci.  
Sostanzialmente se un giurato è abbinato alla sezione
può accedere alle immagini che saranno abbinate alla sezione
e forse è indifferente che l'abbinamento sia con la sezione 1234 + concorso 019948b6-3809-75e3-8cdf-16a644722c58
piuttosto che con la sezione 889be1a8-815f-4860-b429-b83126c3fa21.  
*un campo è meglio di due*, per non sbagliare +1 o -1 uuid si copiaincolla e via.
Scegliendo uuid potrei anche fare come per la creazione dei Contest, prima
creo la scheda e carico i dati di abbinamento alle foreign key, poi
faccio integrare i dati, non ci potrà comunque essere una sezione senza codice.  
* contest_id  
uuid per forza, è fk: contests.id
* code  
Deve rispecchiare il code della tabella federation_sections, quindi definito uguale.  
Tecnicamente un concorso senza patrocini può anche battezzare le sezioni
*A. B. C. D.* oppure *1. 2. 3.*, non cambia la regola di fondo: ogni sezione un codice
unico (all'interno del concorso).

[Mysql local](http://localhost:8888/phpMyAdmin5/)

### Factory no seeders no

La validation rules prevede che contest_id sia exists in contests.id ma
poi il code è libero se il flag under_patronage vale N, il name_en
può essere preso paro paro *(non DEVE, può)* dalla FederationSections.  
Se il concorso è sotto due sponsor e questi non concordano con le sigle,
p.es. `BW` al posto di `M` per le immagini monocromatiche, la validazione
si complica e resta possibile adottando un Validator dedicato.

Ricordarsi di mettere nel Model un __construct()
che richiami la tabella padre. Quindi saranno ereditate
dalla classe figlio anche le funzioni della classe padre, oltre
a richiedere una istanza della classe padre quando si crea
una istanza della classe figlio. Si intende che se la classe ConcorsiSezioni
ha un codice di sezione dalla classe FederazioniSezioni, questo
è soggetto a validazione, mentre invece la classe concorsiSezioni ha
una dipendenza dalla classe Concorsi.

## SoftDeletes() a cascata

Cercando (mando in crisi anche l'IA) trovo che c'è modo di facilitare
la gestione delle cancellazioni tra tabelle padre-figlio.
È disponibile un pacchetto che richiede di aggiungere una colonna datetime
`parent_deleted_at` e questa consente di risolvere un problema.

1. *Caso A* Padre.deleted_at viene scritto, usando un trigger
da impostare viene attivato anche Figlio.deleted_at  
Situazione normale, pare.
1. *Caso B* Padre.deleted_at viene revocato e sempre con lo stesso
trigger anche tutti i Figlio.delete_at sono riattivati.
1. Ma metti *Caso C* che Figlio.deleted_at fosse già impostato
prima di cancellare Padre? Come torno alla situa originale?  
Una prima idea, per niente stupida, Se era già impostato non
lo modifico, quindi quando ripristino Padre devo ripristinare
*solo* i Figlio che hanno Figlio.deleted_at >= Padre.deleted_at

[Delete Child Models when a Parent id Deleted](https://laravel-news.com/laravel-soft-delete-parent)
propone un package e un sistema di accoppiamento dinamico aggiungendo
alle tabelle Figlio una colonna `parent_deleted_at`, e indicare chi sono
i padri e chi i figli.
