# Diario dello sviluppatore, data 25 settembre 2025

Nav: [index](../index.md) : [TDL](../TDL.md) : [log](/storage/logs/laravel.log)

## Contest (section) Jury List

Appunto: quando faccio inserimento per il giurato al concorso lo faccio N volte.
Motivo, noto: esiste un indice di non ripetizione, tuttavia comprende anche la data
di inizio attivit√†, e questa cambia tra un record e l'altro. Evitabile: S√¨,
a patto di incapsulare la gestione della tabella in un sistema che tenga conto
delle date. Come nel lavoro vecchio posso avere una tabella con Chiave, Data inizio, Data fine.
a pari chiave i periodi non si devono intersecare, ovvero non deve esserci una
data fine di un record che supera la data inizio di un altro record.
Si possono creare dei buchi? S√¨, si possono creare dei buchi a patto che abbia senso.
L'alternativa, se non fossero ammessi dei buchi, √® quella della mono-data,
solo data inizio con scadenza a una data inizio successiva, o solo data termine,
con inizio a una data precedente.  
**Per ora resta in sospeso**

## Contest (section) Award List / Add (& Modify)

```php
$ php artisan make:migration create_contest_awards_table

   INFO  Migration [database/migrations/2025_09_25_101235_create_contest_awards_table.php] created successfully.  
```

* id uuid? serve?
* contest_id uuid s√¨
* section_id nullable uuid s√¨
* award code string|10
* award_name string en/local
* is_award Y/N Premio o Menzione
* winner_work_id nullable uuid works.id
* winner_user_id nullable uuid users.id

legami: UserContact, Work, Contest, ContestSection

Attenzione: ci sono anche i premi ai gruppi pi√π numerosi,
quindi devo prevedere premi senza vincitori "singoli",
e i gruppi dovrei inserirli nella tabella delle organizations.

* winner_name nullable string

```php
$ php artisan make:model ContestAward -f

   INFO  Model [app/Models/ContestAward.php] created successfully.  ‚úÖ

   INFO  Factory [database/factories/ContestAwardFactory.php] created successfully.  
```

Rimosso il factory, non vado a creare in automatico dei concorsi a meno che
non riesca a generarli partendo da un dump del database.

```php
$ php artisan livewire:make Contest/Award/Add
 COMPONENT CREATED  ü§ô

CLASS: app/Livewire/Contest/Award/Add.php
VIEW:  resources/views/livewire/contest/award/add.blade.php
```

Parto come per la pagina di caricamento delle sezioni e della giuria:
una prima parte di header, con le indicazioni del concorso che si ripetono
uguali alle altre pagine, e poi la lista delle sezioni + una prima riga "di concorso" con il numero di premi della sezione, quindi al centro la
lista dei premi (in ordine) e in fondo il modulo per l'aggiunta del premio.

**VALUTARE** se sia il caso di scambiare modulo ed elenco, mettendo il primo in testa e il resto sotto.

## Convalide complesse (ma anche yes/no)

[Video YT per convalidare un lnk YT](https://youtu.be/TXYCtTfouPg?si=FoPVYUspVeFEmva6)

* Si pu√≤ creare un Rule in cui ci sar√†
* la funzione *validate()*, che ha 3 input: il nome del campo, il valore/il campo, una funzione per indirizzare i messaggi di errore  
`public function validate(string $attribute, $mixed $value, Closure $fail) {}`  
**OVVIO?** la funzione convalida e non MODIFICA il campo. Quindi giochetti come "vale Y/N, quindi se non √® Y lo FORZO a N e sono a posto" non sono convalide.
A me per esempio serve verificare per uno UserRole se esiste gi√† una T-upla
che condivide gli stessi campi e ha delle date inizio / fine che si
sovrappongono a una gi√† presente, e quindi avvisare "modifica il record,
non puoi inserirne uno nuovo". La modifica prender√† il "payload" nuovo e
aggiorner√† il record vecchio, facendolo terminare *data fine*
al momento dell'aggiornamento, inserendo poi dal momento dell'aggiornamento il nuovo record e facendolo terminare alla *data fine* che era stabilita
per il vecchio record o per una nuova data fine da stabilire.
