# Diario dello sviluppatore, data 17 gennaio 2026

* [index](../index.md) |
  [project](https://github.com/users/mrai64/projects/1/views/1?filterQuery=is%3Aopen&sortedBy%5Bdirection%5D=asc&sortedBy%5BcolumnId%5D=Title) Lista delle questioni

* [◀️ Diario di ieri](./2026-01-16_IT.md)

* [Route](/routes/web.php)

* run <http://yapcp.test/>

* User Doc <http://yapcp.test/docs/1.0/>  
[index](/resources/docs/1.0/index.md)
[log](/storage/logs/laravel-2026-01-17.log)  
ngnix log  `open ~/Library/Application\ Support/Herd/Log`  
`open ./storage/logs/`

## Today Do list

* Revisione codice

## Revisione codice

Partendo dai modelli sto sistemando secondo lo standard PSR-12
e ho installato Pint e ho installato Code Sniffer.
Però non vanno d'accordo. banalmente uno vuole mettere
spazi attorno agli operatori binari quindi `$alfa.$beta`
diventa `$alfa . $beta`, e poi Pint va a rimettere tutto
attaccato.

Mi sono **spaventato** per la quantità di modifiche che
ho fatto senza testare. Ed ero pronto a tornare all'Ante
modifiche PSR-12 per poi procedere a passo di formica con
una modifica alla volta. Però invece la cosa funziona,
una piacevole non sorpresa perché tra cambiare nome
a una variabile e perdersi di fare la stessa modifica in
blade e controller è un attimo.

## Job Supervisor: Laravel Horizon

Le code sono code. Ovvero il compito viene messo
via per essere eseguito e NON viene eseguito subito
facendo aspettare la persona se nei parametri
del file `.env` non c'è `sync`. Ma si perde il vantaggio
di usare i job.

A richiesta Gemini mi dice che c'è da eseguire il comando

```sh
php artisan queue:listen
```

manualmente per l'ambiente di sviluppo, in alternativa a

```sh
php artisan queue:work
```

Sempre per l'ambiente di sviluppo. C'è bisogno di un
preposto, di un coso che segua i job e questo coso in
Laravel è il prodotto **Laravel Horizont**. È quello che
si deve imparare perché viene usato in produzione,
non è un prodotto "fa tutto lui" e i concetti che
pretende tu sappia già sono quelli della gestione job.
Serve quantomeno studiare il prodotto per capire
come va configurato epr funzionare in loco e in un server.  
[Laravel Horizont](https://laravel.com/docs/12.x/horizon)

## No more _en

Quando ho iniziato a realizzare la piattaforma
ho pensato a un bilinguismo, o meglio
a tenere in archivio la versione inglese e quella
in lingua locale. La cosa però deve essere
antipatica a qualcuno, perché ricordo di avere visto
un qualche tutorial contro questa prassi.  
Quello che non ricordo nitidamente è se fosse
un tutorial su YT oppure una risposta in StackOverflow. O Medium.
Verificato su YT: nessun tutorial sull'argomento in cronologia.

Amen, quando lo ritrovo non lo tralascerò.

## PSR-12 ContestAward

Se una tabella è in relazione con altre la funzione
di relazione va scritta a prescindere? Se non viene
usata, il legame può essere un vincolo di database.

[Chiedi a Gemini del 17 gennaio 2026](./2026-01-17_gemini_say_1.md)

Fare sempre e comunque le funzioni di relazione è
cosa buona e giusta. A) non consuma chissà quante risorse,
viene caricata solo quando serve. B) Se la relazione c'è
prima o poi qualcuno la userà.

## Revisione del codice (2)

Segue dal precedente, ho messo mano al Model ContestAward
inserendo anche le funzioni di relazione alle tabelle
legate. L'array per convalidare il campo Y/N messo in maiuscolo
perché costante viene usato per verificare che l'input sia in
array ma allo stesso tempo ho ribaltato i record Y e N in modo
che 'N' No corrisponda anche all'indice 0 / false.

### TODO Verificare per tutte le relazioni

Verificare per i Model finora valutati che **esistano**
per le colonne "destinatarie" di una relazione
degli **indici**, anche *not unique*.

```sql
SELECT `pcp_user_contacts`.`country_id`,
       `pcp_user_contacts`.`last_name`,
       `pcp_user_contacts`.`first_name`,
       `pcp_contest_participants`.`fee_payment_completed`,
       `pcp_contest_participants`.`user_id`
  FROM `pcp_contest_participants`
  LEFT JOIN `pcp_user_contacts` 
    ON (`pcp_contest_participants`.`user_id` = `pcp_user_contacts`.`user_id`) 
 WHERE `pcp_contest_participants`.`contest_id` = 'e8ac5674-c3d1-4afa-adaf-a7d5ed82d292'
ORDER BY
  `pcp_user_contacts`.`country_id`,
  `pcp_user_contacts`.`last_name`,
  `pcp_user_contacts`.`first_name`;
```
  
Gemini suggerisce 2 approcci per ottenere questi dati, il secondo è questo:

```php
use App\Models\ContestParticipant;

$results = ContestParticipant::query()
    ->leftJoin('pcp_user_contacts', 'pcp_contest_participants.user_id', '=', 'pcp_user_contacts.user_id')
    ->where('contest_id', 'e8ac5674-c3d1-4afa-adaf-a7d5ed82d292')
    ->select([
        'pcp_user_contacts.country_id',
        'pcp_user_contacts.last_name',
        'pcp_user_contacts.first_name',
        'pcp_user_contacts.user_id'
        'pcp_contest_participants.fee_payment_completed',
    ])
    ->orderBy('pcp_user_contacts.country_id')
    ->orderBy('pcp_user_contacts.last_name')
    ->orderBy('pcp_user_contacts.first_name')
    ->orderBy('pcp_user_contacts.user_id')
    ->get();
```
