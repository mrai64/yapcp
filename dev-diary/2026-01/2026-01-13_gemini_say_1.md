# Gemini say del 13 gennaio

## Domanda 1

Anche avendo nei primi 20 record almeno un contest_work andato a premio, non arriva nessun record award valorizzato. la relazione tra contest_works e contest_awards c'è, basata su contest_works.section_id = contrest_awards.section_id AND contest_works.work_id = contest_awards.winner_work_id 

<?php

/**
 * Excel Export Report generate
 *
 * federation: FIAF Italian photographic societes federation Federazione Italiana Associazioni Fotografiche
 * report: Foto partecipanti ed esiti
 */

namespace App\Exports;

use App\Models\Contest;
use App\Models\ContestWork;
use App\Models\Federation;
use Illuminate\Contracts\View\View;
use Maatwebsite\Excel\Concerns\FromView;

class Fiaf2WorksExport implements FromView
{
    // data for view
    protected string $contestId; //    cid

    protected string $federationId; // fid

    protected string $thisYear;

    protected $contest;

    protected $partecipazioni;

    protected $reportData;

    /**
     * Fill array for view
     */
    public function __construct(string $cid, string $fid) // from controller
    {
        set_time_limit(120);
        // zero trust
        if (Contest::where('id', $cid)->count() === 0) {
            abort(403);
        }
        $contestId = $cid;
        $this->contestId = $cid;

        if (Federation::where('id', $fid)->count() === 0) {
            abort(403);
        }
        $federationId = $fid;
        $this->federationId = $fid;
        $this->thisYear = date('Y');

        // contest n contest sections
        $this->contest = Contest::with(['sections' => function ($q) {
            $q->orderBy('code');
        }])->find($cid);

        // pick works participation and results
        $partecipazioni = ContestWork::query()
            ->where('contest_works.contest_id', $cid)
            // Carichiamo tutte le relazioni necessarie (Eager Loading)
            ->with([
                'section', //                     contest_work->section
                'work', //                        contest_work->work
                'award', //                       contest_work->award
                'author' => function ($query) { //contest_work->author
                    $query->select('user_id', 'first_name', 'last_name', 'country_id');
                },
                'author.contactMores' => function ($query) use ($fid) {
                    $query->where('federation_id', $fid);
                },
            ])
            // join and sorted by
            ->join('user_contacts', 'contest_works.user_id', '=', 'user_contacts.user_id')
            ->join('contest_sections', 'contest_works.section_id', '=', 'contest_sections.id')
            ->join('works', 'contest_works.work_id', '=', 'works.id')
            ->orderBy('user_contacts.last_name')
            ->orderBy('user_contacts.first_name')
            ->orderBy('contest_sections.code')
            ->orderBy('contest_works.portfolio_sequence')
            // select only fields from contest_works to avoid field name misunderstand
            ->select('contest_works.*')
            ->limit(36) // dbg
            ->get();

        // at last building map
        $reportData = $partecipazioni->map(function ($row) {

            // user_contact_more
            $mores = $row->author->contactMores ?? collect([]);  // data, or empty array
            // function over mores - ?defined for every call?
            $getMore = function ($fieldName) use ($mores) {
                $item = $mores->firstWhere('field_name', $fieldName);

                return $item ? $item->field_value : null; // value or default empty string
            };

            // excel_row
            return [
                'lastName' => $row->author->last_name,
                'firstName' => $row->author->first_name,
                'italianTaxId' => $getMore('italianTaxId') ?? 'XXXXXXXXXXXXXXXX',
                'cardId' => $getMore('cardId') ?? '000000',
                'distinction' => $getMore('fiafDistinctions') ?? '$$$$$',
                'section' => 'DIG', // dig | portfolio
                'theme_code' => $row->section->code,
                'work_title' => $row->work->title_en,
                'yof1st' => $row->work->reference_year ?? $this->thisYear,
                'admit' => $row->is_admit,
                'award' => $row->award,
            ];
        }); // map()
        $this->reportData = $reportData;

    } // __construct()

    /**
     * Build vew to pass as excel table
     *
     * @return void
     */
    public function view(): View
    {
        set_time_limit(120);

        return view('livewire.contest.report.fiaf2-works', [
            'contest' => $this->contest,
            'patronage_code' => $this->contest->federation_list,
            'reportData' => $this->reportData,
        ]);
    }
}

## Risposta 1

Il problema per cui i record `award` risultano vuoti (null) nonostante l'Eager Loading (`with('award')`) è dovuto al fatto che Laravel, di default, cerca la relazione basandosi su una singola chiave esterna.

Poiché la tua relazione tra `ContestWork` e `ContestAward` è **composita** (richiede sia `section_id` che `work_id`), il sistema di relazioni standard di Eloquent non riesce a collegarli automaticamente a meno che tu non abbia definito una logica specifica nel modello.

Ecco come risolvere il problema agendo su due fronti:

---

### 1. Definizione della Relazione nel Modello

Nel modello `ContestWork`, la relazione `award()` deve essere definita in modo da gestire la doppia colonna. Se non usi un plugin per chiavi composite, devi usare una Closure nel `hasOne`:

```php
// App\Models\ContestWork.php

public function award()
{
    // Colleghiamo per work_id e poi filtriamo per section_id del record corrente
    return $this->hasOne(ContestAward::class, 'winner_work_id', 'work_id')
                ->whereColumn('section_id', 'contest_works.section_id');
}

```

---

### 2. Ottimizzazione nel `Fiaf2WorksExport`

Nel tuo export, stai usando `select('contest_works.*')`. Questo è corretto per evitare conflitti di nomi, ma assicurati che le colonne `work_id` e `section_id` siano presenti (essendo in `*`, ci sono).

Tuttavia, c'è un dettaglio importante nel tuo codice: stai usando i `join` per l'ordinamento, ma poi usi `with` per i dati.

**Perché `award` non compare?**
Se la relazione nel modello è definita in modo standard (solo su un ID), Eloquent esegue una query separata tipo:
`SELECT * FROM contest_awards WHERE winner_work_id IN (...)`
senza controllare la `section_id`, fallendo l'associazione se un'opera ha vinto in una sezione ma non in quella visualizzata.

### 3. Soluzione rapida (senza cambiare il Modello)

Se non vuoi toccare il modello, puoi forzare il caricamento del premio tramite un `leftJoin` direttamente nella query principale dell'export. Questo ti garantisce che il dato sia presente nella riga:

```php
$partecipazioni = ContestWork::query()
    ->where('contest_works.contest_id', $cid)
    ->with([
        'section',
        'work',
        'author' => function ($query) {
            $query->select('user_id', 'first_name', 'last_name', 'country_id');
        },
        'author.contactMores' => function ($query) use ($fid) {
            $query->where('federation_id', $fid);
        },
    ])
    ->join('user_contacts', 'contest_works.user_id', '=', 'user_contacts.user_id')
    ->join('contest_sections', 'contest_works.section_id', '=', 'contest_sections.id')
    ->join('works', 'contest_works.work_id', '=', 'works.id')
    // Aggiungiamo il LEFT JOIN per gli awards su due colonne
    ->leftJoin('pcp_contest_awards', function ($join) {
        $join->on('contest_works.work_id', '=', 'pcp_contest_awards.winner_work_id')
             ->on('contest_works.section_id', '=', 'pcp_contest_awards.section_id');
    })
    ->orderBy('user_contacts.last_name')
    ->orderBy('user_contacts.first_name')
    ->orderBy('contest_sections.code')
    ->orderBy('contest_works.portfolio_sequence')
    // Seleziona tutto da contest_works e le colonne che ti servono da awards
    ->select('contest_works.*', 'pcp_contest_awards.award_name as award_title') 
    ->limit(36)
    ->get();

```

---

### Perché non vedevi nulla nel `map()`?

Nel tuo `map()`, scrivi:
`'award' => $row->award`

Se usi il **metodo 3 (Left Join)**, il dato non sarà più dentro un oggetto `award`, ma sarà una proprietà diretta del record `$row`. Dovrai quindi cambiare il map in:
`'award' => $row->award_title` (o il nome della colonna che hai scelto nella select).

### Un consiglio sulle prestazioni

Vedo che usi `set_time_limit(120)`. Se il numero di record aumenta, il `map()` con all'interno `firstWhere` sulle `contactMores` potrebbe rallentare.
Ti consiglio di aggiungere le tabelle dei nomi (`user_contacts`) già nella `select` del join iniziale per evitare di accedere a `$row->author->last_name`, che scatena una proprietà dinamica di Eloquent per ogni riga.

**Ti servono le istruzioni per rinominare correttamente le tabelle nella query per evitare l'errore "Table not found" che avevamo prima?** (Vedo che nel codice sopra usi `contest_awards` ma nell'errore precedente il sistema cercava `pcp_awards`).

## Domanda 2

Per spostare il tutto in JOBS

## Risposta 2

Spostare la generazione di un report Excel in un **Job in background** è la scelta migliore per evitare timeout del server (specialmente con export pesanti) e migliorare l'esperienza utente.

Ecco la procedura passo-passo per migrare la tua logica.

---

### 1. Crea la classe Job

Esegui il comando: `php artisan make:job ExportFiaf2WorksJob`

Il Job riceverà i parametri `cid` e `fid`, eseguirà la query e salverà il file sul disco.

```php
namespace App\Jobs;

use App\Exports\Fiaf2WorksExport;
use Maatwebsite\Excel\Facades\Excel;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;

class ExportFiaf2WorksJob implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    public $timeout = 300; // 5 minuti di tempo massimo

    public function __construct(
        protected string $cid, 
        protected string $fid,
        protected string $filename
    ) {}

    public function handle()
    {
        // Utilizziamo l'istanza della tua classe Export
        // Salva il file nella cartella storage/app/public/exports
        Excel::store(
            new Fiaf2WorksExport($this->cid, $this->fid), 
            'exports/' . $this->filename, 
            'public'
        );
        
        // Qui potresti inviare una notifica all'utente o salvare un record nel DB
    }
}

```

---

### 2. Modifica l'Export per supportare `store`

La tua classe `Fiaf2WorksExport` deve implementare `Maatwebsite\Excel\Concerns\Exportable`. Questo permette di gestire meglio il processo fuori dal controller.

```php
use Maatwebsite\Excel\Concerns\Exportable;

class Fiaf2WorksExport implements FromView
{
    use Exportable;
    // ... il resto del tuo codice rimane uguale ...
}

```

---

### 3. Lancia il Job dal Controller

Invece di restituire direttamente il download, il controller "prenota" il lavoro e avvisa l'utente.

```php
public function exportFiaf2Works($cid, $fid)
{
    $filename = "report_fiaf_{$cid}_" . now()->timestamp . ".xlsx";

    // Dispatch del Job
    ExportFiaf2WorksJob::dispatch($cid, $fid, $filename);

    return back()->with('status', 'Il report è in fase di generazione. Riceverai una notifica a breve.');
}

```

---

### 4. Gestione della relazione Award nel Job

Dato che il Job non ha una sessione attiva o limiti di memoria stretti come una richiesta HTTP, assicurati che la query sia super-ottimizzata. Riprendendo il problema del join sulle due colonne:

**All'interno del costruttore di `Fiaf2WorksExport**`, usa il `leftJoin` esplicito per essere sicuro che l'award arrivi insieme al record principale senza fare 1000 micro-query:

```php
$partecipazioni = ContestWork::query()
    ->where('contest_works.contest_id', $cid)
    ->join('pcp_user_contacts', 'contest_works.user_id', '=', 'pcp_user_contacts.user_id')
    ->join('pcp_contest_sections', 'contest_works.section_id', '=', 'pcp_contest_sections.id')
    // Join su doppia colonna per gli awards
    ->leftJoin('pcp_contest_awards', function ($join) {
        $join->on('contest_works.work_id', '=', 'pcp_contest_awards.winner_work_id')
             ->on('contest_works.section_id', '=', 'pcp_contest_awards.section_id');
    })
    ->select([
        'contest_works.*',
        'pcp_contest_awards.award_name as award_title', // Nome del premio
        'pcp_user_contacts.last_name',
        'pcp_user_contacts.first_name'
    ])
    ->get();

```

---

### Cosa devi configurare ora?

1. **Queue Driver:** Assicurati che nel tuo file `.env` il `QUEUE_CONNECTION` non sia `sync`. Usa `database` o `redis`.
2. **Worker:** Ricordati di avviare il processo che lavora i job: `php artisan queue:work`.
3. **Storage:** Se salvi in `public`, assicurati di aver lanciato `php artisan storage:link` per rendere i file scaricabili.

Vuoi che integriamo anche un sistema di **notifica via database/mail** per avvisare l'utente quando il file Excel è pronto per il download?

