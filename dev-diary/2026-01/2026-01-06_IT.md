# Diario dello sviluppatore, data 6 gennaio 2026

* [index](../index.md) |
  [project](https://github.com/users/mrai64/projects/1/views/1?filterQuery=is%3Aopen&sortedBy%5Bdirection%5D=asc&sortedBy%5BcolumnId%5D=Title) issue list |
  [To Do List](../TDL.md) svuotato  

* [Route](/routes/web.php)

* [◀️ Diario di ieri](./2026-01-05_IT.md)

* run <http://yapcp.test/>
* User Doc <http://yapcp.test/docs/1.0/> [index](/resources/docs/1.0/index.md)
* [log](/storage/logs/laravel-2026-01-06.log)  | ngnix log  `open ~/Library/Application\ Support/Herd/Log`  `open ./storage/logs/`

## Today Do list

* Completare popolamento excel

## Una questione di tempo (e memoria)

In effetti anche per l'elenco dei partecipanti ho avuto a
che fare con un paio di count(), e una query complessa
che mi hanno fatto fare con coalesce e derivati.
Qui la questione "ha partecipato" diventa una if su count() > 0 per la presenza di lavori e il conteggio delle ammissioni è una clausola with() se ho capito bene.
C'è sempre il quid di mettere in orizzontale le sezioni
del concorso, per cui l'idea di avere una prima query con
solo i dati anagrafici, Poi girata in array indice user_id,
e N query ma non una per concorrente, una per sezione,
anche queste girate a loro volta in array per indice user_id
potrebbe ridurre i tempi.

Le relazioni di contests:

* 1:1 contests.country_id > countries.id
* 1:1 contests.organization_id > organizations.id
* N:1 contests.circuit_id > contests.id (with is_circuit == 1)
* 1:N contests.id < contest_awards.contest_id
* 1:N contests.id < contest_participants.contest_id
* 1:N contests.id < contest_sections.contest_id
* 1:N contests.id < contest_votes.contest_id
* 1:N contests.id < contest_waitings.contest_id
* 1:N contests.id < contest_works.contest_id
* 1:N contests.id < user_roles.contest_id

Le relazioni di user_contacts:

* 1:1 user_contacts.user_id > users.id
* 1:1 user_contacts.country_id > countries.id
* 1:1 user_contacts.timezone > timezones.id
* 1:N user_contacts.user_id < contest_awards.winner_user_id
* 1:N user_contacts.user_id < contest_juries.user_contact_id
* 1:N user_contacts.user_id < contest_participants.user_id
* 1:N user_contacts.user_id < contest_waitings.participant_user_id
* 1:N user_contacts.user_id < contest_works.user_id
* 1:N user_contacts.user_id < user_contact_mores.user_id
* 1:N user_contacts.user_id < user_roles.user_id
* 1:N user_contacts.user_id < works.user_id

Percorsi:
1 lettura contests.section_id[]
N lettura dei contest_works per conteggio opere (basta il
COUNT() ) e conteggio is_admit (essendo 1/0 basta il SUM() )
group by contest_works.user_id WHERE
contest_works.section_id = contest_sections.id
1 lettura user_contacts per estrazione dati join contest_participants on (user_contacts.user_id = contest_participants.participant_user_id)
N integrazione dati user_contacts_more per estrazione dati
coalesce federation_mores.default_value

### Concorso

```sql
SELECT `pcp_contests`.*
  FROM `pcp_contests`
 WHERE `pcp_contests`.`id` = 'e8ac5674-c3d1-4afa-adaf-a7d5ed82d292';
```

### Le sezioni del concorso

```sql
-- sezioni in concorso
SELECT `pcp_contest_sections`.`code`,
       `pcp_contest_sections`.`name_en`
  FROM `pcp_contest_sections`
 WHERE `pcp_contest_sections`.`contest_id` = 'e8ac5674-c3d1-4afa-adaf-a7d5ed82d292'
 ORDER BY `pcp_contest_sections`.`code`;
```

Si salta il left join con il concorso,  
Nota: nel concorso suindicato sono definite anche 2 sezioni a portfolio a cui però non
ci son partecipanti né sono gestite. Quella query esce con 5 record ma di fatto sono 3.
Roba di sviluppo, non ci sono errori.

### Tutti i voti e le partecipazioni di tutte le sezioni

```sql
SELECT `pcp_contest_works`.`user_id`, 
       `pcp_contest_sections`.`code`,
       COUNT(`pcp_contest_works`.`id`),
       SUM(`pcp_contest_works`.`is_admit`)
  FROM `pcp_contest_works`
  LEFT JOIN `pcp_contest_sections` 
         ON (`pcp_contest_works`.`section_id` = `pcp_contest_sections`.`id`)
  LEFT JOIN `pcp_contests`
         ON (`pcp_contests`.`id` = `pcp_contest_sections`.`contest_id`)
 WHERE `pcp_contests`.`id` = 'e8ac5674-c3d1-4afa-adaf-a7d5ed82d292'
 GROUP BY `pcp_contest_works`.`user_id`,
          `pcp_contest_works`.`section_id`
 ORDER BY `pcp_contest_works`.`user_id`,
          `pcp_contest_works`.`section_id`;
```

Spesi 18 ms e avute 114 righe. Tecnicamente qui non
dovrebbero esserci buchi: tutte le sezioi e tutte le opere
presentate dovrebbero avere voti e quindi un record qui con
is_admit 1 / 0. Non ci sono record per le due sezioni a
portfolio perché no sono stati caricati dalle verifiche

### Dati personali aggiuntivi della federazione

Dati di default oppure i dati di tabella.

```sql
SELECT `pcp_contest_participants`.`user_id`,
       `pcp_federation_mores`.`federation_id`,
       `pcp_federation_mores`.`field_name`,
       COALESCE(`pcp_user_contact_mores`.`field_value`, 
                `pcp_federation_mores`.`field_default_value`)
  FROM `pcp_contest_participants`,
       `pcp_federation_mores`
  LEFT JOIN `pcp_user_contact_mores`
    ON (`pcp_user_contact_mores`.`federation_id` = `pcp_federation_mores`.`federation_id`
    AND `pcp_user_contact_mores`.`field_name`    = `pcp_federation_mores`.`field_name`)
  WHERE `pcp_contest_participants`.`contest_id` = 'e8ac5674-c3d1-4afa-adaf-a7d5ed82d292'
    AND `pcp_federation_mores`.`federation_id` = 'FIAF'
 ORDER BY `pcp_contest_participants`.`user_id`,
       `pcp_federation_mores`.`federation_id`,
       `pcp_federation_mores`.`field_name`;
```

Questa restituisce i campi in 3,9 ms per 144 righe

### Tutti i dati dei partecipanti (esclusi i dati aggiuntivi)

```sql
SELECT `pcp_user_contacts`.`user_id`,
       `pcp_user_contacts`.`country_id`,
       `pcp_user_contacts`.`last_name`,
       `pcp_user_contacts`.`first_name`,
       `pcp_user_contacts`.`address`,
       `pcp_user_contacts`.`address_line2`,
       `pcp_user_contacts`.`city`,
       `pcp_user_contacts`.`region`,
       `pcp_user_contacts`.`postal_code`
  FROM `pcp_user_contacts`
  LEFT JOIN `pcp_contest_participants`
    ON (`pcp_contest_participants`.`user_id` = `pcp_user_contacts`.`user_id`)
 WHERE `pcp_contest_participants`.`contest_id` = 'e8ac5674-c3d1-4afa-adaf-a7d5ed82d292'
 ORDER BY `pcp_user_contacts`.`user_id`;
```

Restituisce 48 campi in 8,8 ms

Quindi i tempi per renderizzare la view non dovrebbero essere troppo alti.
Controintuitivo: togliendo l'order by dovrebbe fare meno lavoro,
invece il tempo si allunga a 35,5 ms

### Cui prodest?

**A cosa serve tutto questo: CHIARIRE** le idee su dove pescare i dati
e quali sono i tempi di recupero per un caso standard.
Vero che 48 partecipanti a un concorso sono 1/10 di quanto ci si
aspetti, ma sono 1/5 o 1/6 della partecipazione reale.
Non sono previsti concorsi con migliaia di partecipanti.

Passo la palla a Gemini: [Chiedi a Gemini](./2026-01-06_gemini_say_1.md)

Da verificare:

* ✅ Il modello [ContestParticipant](/app/Models/ContestParticipant.php) deve avere RELATIONSHIP con i modelli UserContact, ContestWork, UserContactMore
* ✅ Il modello ConteatWork deve avere RELATIONSHIP con ContestSection

Aggiunta una relation, ma ci siamo.

Qui poi viene il momento di fede. Io
francamente alla vecchia maniera voglio
mettere insieme manualmente o quasi i
record.

* blade [fiaf1-participants](/resources/views/livewire/contest/report/fiaf1-participants.blade.php)
* controller della view [FIAF1Participants](/app/Http/Controllers/Contest/Report/Fiaf1Participants.php)  
questo però fa il lavoro finale, controlla il $cid che
riceve dal route, ma dovrebbe ricevere $cid e $fid concorso
e federazione sponsor (oppure recuperare la lista delle
federazioni sponsor come indicato nei giorni scorsi.)
* route [web](/routes/web.php), aggiungo un secondo parametro
