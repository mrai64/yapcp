# Diario dello sviluppatore, data 6 gennaio 2026

* [index](../index.md) |
  [project](https://github.com/users/mrai64/projects/1/views/1?filterQuery=is%3Aopen&sortedBy%5Bdirection%5D=asc&sortedBy%5BcolumnId%5D=Title) issue list |
  [To Do List](../TDL.md) svuotato  

* [Route](/routes/web.php)

* [◀️ Diario di ieri](./2026-01-05_IT.md)

* run <http://yapcp.test/>
* User Doc <http://yapcp.test/docs/1.0/> [index](/resources/docs/1.0/index.md)
* [log](/storage/logs/laravel-2026-01-06.log)  | ngnix log  `open ~/Library/Application\ Support/Herd/Log`  `open ./storage/logs/`

## Today Do list

* Completare popolamento excel

## Una questione di tempo (e memoria)

In effetti anche per l'elenco dei partecipanti ho avuto a
che fare con un paio di count(), e una query complessa
che mi hanno fatto fare con coalesce e derivati.
Qui la questione "ha partecipato" diventa una if su count() > 0 per la presenza di lavori e il conteggio delle ammissioni è una clausola with() se ho capito bene.
C'è sempre il quid di mettere in orizzontale le sezioni
del concorso, per cui l'idea di avere una prima query con
solo i dati anagrafici, Poi girata in array indice user_id,
e N query ma non una per concorrente, una per sezione,
anche queste girate a loro volta in array per indice user_id
potrebbe ridurre i tempi.

Le relazioni di contests:

* 1:1 contests.country_id > countries.id
* 1:1 contests.organization_id > organizations.id
* N:1 contests.circuit_id > contests.id (with is_circuit == 1)
* 1:N contests.id < contest_awards.contest_id
* 1:N contests.id < contest_participants.contest_id
* 1:N contests.id < contest_sections.contest_id
* 1:N contests.id < contest_votes.contest_id
* 1:N contests.id < contest_waitings.contest_id
* 1:N contests.id < contest_works.contest_id
* 1:N contests.id < user_roles.contest_id

Le relazioni di user_contacts:

* 1:1 user_contacts.user_id > users.id
* 1:1 user_contacts.country_id > countries.id
* 1:1 user_contacts.timezone > timezones.id
* 1:N user_contacts.user_id < contest_awards.winner_user_id
* 1:N user_contacts.user_id < contest_juries.user_contact_id
* 1:N user_contacts.user_id < contest_participants.user_id
* 1:N user_contacts.user_id < contest_waitings.participant_user_id
* 1:N user_contacts.user_id < contest_works.user_id
* 1:N user_contacts.user_id < user_contact_mores.user_id
* 1:N user_contacts.user_id < user_roles.user_id
* 1:N user_contacts.user_id < works.user_id

Percorsi:
1 lettura contests.section_id[]
N lettura dei contest_works per conteggio opere (basta il
COUNT() ) e conteggio is_admit (essendo 1/0 basta il SUM() )
group by contest_works.user_id WHERE
contest_works.section_id = contest_sections.id
1 lettura user_contacts per estrazione dati join contest_participants on (user_contacts.user_id = contest_participants.participant_user_id)
N integrazione dati user_contacts_more per estrazione dati
coalesce federation_mores.default_value

### Tutti i voti e le partecipazioni di tutte le sezioni

```sql
SELECT `pcp_contest_works`.`user_id`, 
       `pcp_contest_works`.`section_id`,
       COUNT(`pcp_contest_works`.`id`),
       SUM(`pcp_contest_works`.`is_admit`)
  FROM `pcp_contest_works`
  LEFT JOIN `pcp_contest_sections` 
         ON (`pcp_contest_works`.`section_id` = `pcp_contest_sections`.`id`)
  LEFT JOIN `pcp_contests`
         ON (`pcp_contests`.`id` = `pcp_contest_sections`.`contest_id`)
 GROUP BY `pcp_contest_works`.`user_id`,
          `pcp_contest_works`.`section_id`
 ORDER BY `pcp_contest_works`.`user_id`,
          `pcp_contest_works`.`section_id`;
```

Senza distinzione di concorsi

```sql
 WHERE `pcp_contests`.`id` = 'e8ac5674-c3d1-4afa-adaf-a7d5ed82d292'
```

spesi 18 ms e 114 righe

```sql
SELECT `pcp_user_contact_mores`.`user_contact_user_id` AS `user_id`,
       `pcp_user_contact_mores`.`federation_id`,
       `pcp_user_contact_mores`.`field_name`,
       `pcp_user_contact_mores`.`field_value`,
       `pcp_federation_mores`.`field_default_value`,
  LEFT JOIN `pcp_federation_mores`
    ON (`pcp_federation_mores`.`federation_id` = `pcp_user_contacts_more`.`federation_id`
    AND `pcp_federation_mores`.`field_name` = `pcp_user_contacts_more`.`field_name`)
  LEFT JOIN `pcp_contest_participants`
    ON (`pcp_contest_participants`.`user_id` = `pcp_user_contact_mores`.`user_contact_user_id`)
  WHERE `pcp_contest_participants`.`contest_id` = 'e8ac5674-c3d1-4afa-adaf-a7d5ed82d292'
  ORDER BY `pcp_user_contact_mores`.`user_contact_user_id`,
           `pcp_user_contact_mores`.`federation_id`,
           `pcp_user_contact_mores`.`field_name`;

```

```sql
SELECT `pcp_contest_participants`.`user_id`,
       `pcp_federation_mores`.`federation_id`,
       `pcp_federation_mores`.`field_name`,
       COALESCE(`pcp_user_contact_mores`.`field_value`, 
                `pcp_federation_mores`.`field_default_value`)
  FROM `pcp_contest_participants`,
       `pcp_federation_mores`
  LEFT JOIN `pcp_user_contact_mores`
    ON (`pcp_user_contact_mores`.`federation_id` = `pcp_federation_mores`.`federation_id`
    AND `pcp_user_contact_mores`.`field_name`    = `pcp_federation_mores`.`field_name`)
  WHERE `pcp_contest_participants`.`contest_id` = 'e8ac5674-c3d1-4afa-adaf-a7d5ed82d292'
    AND `pcp_federation_mores`.`federation_id` = 'FIAF'
 ORDER BY `pcp_contest_participants`.`user_id`,
       `pcp_federation_mores`.`federation_id`,
       `pcp_federation_mores`.`field_name`;
```

Questa restituisce i campi in 3,9 ms per 144 righe

```sql
SELECT `pcp_user_contacts`.`user_id`,
       `pcp_user_contacts`.`country_id`,
       `pcp_user_contacts`.`last_name`,
       `pcp_user_contacts`.`first_name`,
       `pcp_user_contacts`.`address`,
       `pcp_user_contacts`.`address_line2`,
       `pcp_user_contacts`.`city`,
       `pcp_user_contacts`.`region`,
       `pcp_user_contacts`.`postal_code`
  FROM `pcp_user_contacts`
  LEFT JOIN `pcp_contest_participants`
    ON (`pcp_contest_participants`.`user_id` = `pcp_user_contacts`.`user_id`)
 WHERE `pcp_contest_participants`.`contest_id` = 'e8ac5674-c3d1-4afa-adaf-a7d5ed82d292'
 ORDER BY `pcp_user_contacts`.`user_id`;
```

Restituisce 48 campi in 8,8 ms

Quindi i tempi per renderizzare la view non dovrebbero essere troppo alti.
Controintuitivo: togliendo l'order by dovrebbe fare meno lavoro,
invece il tempo si allunga a 35,5 ms

**A cosa serve tutto questo: CHIARIRE** le idee su dove pescare i dati
e quali sono i tempi di recupero per un caso standard.
Vero che 48 partecipanti a un concorso sono 1/10 di quanto ci si
aspetti, ma sono 1/5 o 1/6 della partecipazione reale.
Non sono previsti concorsi con migliaia di partecipanti.
