# Diario dello sviluppatore, data 2 gennaio 2026

* [index](../index.md) |
  [project](https://github.com/users/mrai64/projects/1/views/1?filterQuery=is%3Aopen&sortedBy%5Bdirection%5D=asc&sortedBy%5BcolumnId%5D=Title) issue list |
  [To Do List](../TDL.md) svuotato  

* [Route](/routes/web.php)

* [◀️ Diario di ieri](./2026-01-01_IT.md)

* run <http://yapcp.test/>
* User Doc <http://yapcp.test/docs/1.0/> [index](/resources/docs/1.0/index.md)
* [log](/storage/logs/laravel-2026-01-02.log)  | ngnix log  `open ~/Library/Application\ Support/Herd/Log`  `open ./storage/logs/`

## Today Do list

* User Contact Modify, la parte per le federazioni

## UserContact Modify / 5 Federation Additional fields

Siamo ancora a questo ma si vede la luce, ieri gettata
la spugna. Fino alla cancellazione delle tabelle.
Via tutto, rifatto tutto in meno di 4 ore:

* rifatte tabelle con nomi diversi, così non ci fossero
'spurie'
* tolto e rimesso il link in route()
* svuotato tutto il component e il blade
* ri-chiesto a gemini che fare
* messo su il component seguendo le indicazioni di gemini

e ieri sera, va da ben, che si è registrato il record.
C'è però un però: problema validazione.
La validazione va applicata sì, ma quando il campo
ha un valore predefinito che non rientra nella definizione
mi serve una regola di convalida "Oppure", esempio:
tessera da '010001' a '999999' OPPURE '000000'
quindi come espressione regolare '000000'|([0][1-9][0-9]{4})|([1-9][0-9]{5})

Intanto c'è modo di validare un campo "se c'è":  
` 'email' => 'sometimes|required|email', `  
per convalide complicate serve usare una Form Request che
usa dei Service Provider.  Onestamente queste diventerebbero
delle funzioni da indirizzare "ri creando" una situazione
di regole non dinamiche e cambiando, gioco di parole,
le regole delle regole.

Definizione "semplice" > elenco di definizioni in stringa su tabella >
modulo dinamico.

Definizione con Form Request > elenco di moduli da chiamare >
modulo classico / statico.

La clausola `sometimes` consentirebbe di adottare il valore di
default come placeholder, che viene visualizzato in html
fintanto che il campo è vuoto.
Il campo quindi diventerebbe la rappresentazione del contenuto
della tabella SE C'È. L'estrazione dei dati *tornerebbe*
ad essere in join con la tabella dei dati user_contact_more
in modo da avere una stringa vuota '' oppure il contenuto
del campo.

`sometimes|` diventerebbe il prefisso di tutte le regole,

Soddisfazione: funziona: **commit**

Poi pensiamo a sistemare header e css
–
Fatto **commit**

---

## Next stop

Prossimo passo: Documentazione

* ricordarsi di mettere le immagini [qui](/storage/app/public/docs/)
* mentre la documentazione va [qui](/resources/docs/1.0/)

Posso includere /storage/app/public/docs tra le cartelle che caricano
dati in repository? Una buona parte del contenuto di LaRecipe
è immagine e non sta nel repository.

Mmm pare non sia utile.  
Nel frattempo però guardando nel vendor di LaRecipe
ho trovato qualcosa di interessante che riguarda le
github Action. In caso di push viene fatto prima il push dal master e oi il pull dal master.
Questo consente - intuisco - in caso di lavoro di gruppo
che si portino in casa le modifiche a master fatte da altri nel frattempo.

## Next stop: [Issue #90](https://github.com/mrai64/yapcp/issues/90)

Adesso che i "campi aggiuntivi" della cartella
user_contact_mores ci sono e sono caricabili,
devo aggiungere una relationship al modello
user_contact che fornisca il set di campi di
tutte le federazioni, integrandolo con i valori
predefiniti che sono nella tabella federation_more.

Quindi la relation è con federation_more, in cui però
con left join e coalesce pesco gli eventuali valori
presenti in user_contact-mores.

Voglio aggiungere i campi, come se fossero colonne della
tabella, e non lo sono.
Quindi numero tessera, codice fiscale ecc.

Torniamo al foglio excel di [issue #90]

* Report per la federazione: FIAF
* Descrizione del report: File partecipanti e ammissioni

Campi del report

* riga 1
  * titolo-descrizione: denominazione concorso
    provenienza: contests.name con contests.id == cid
* riga 2
  * intestazioni
    * patrocinio concorso
    * tessera fiaf
    * codice fiscale
    * cognome autore
    * nome autore
    * indirizzo autore
    * CAP
    * Autore Città ( ma sarebbe meglio Città Autore)
    * Autore Provincia
    * Autore email
    * Onorificenze  
      seguite da coppie di colonne dedicate ai temi - sezioni
    * sezione - partecipazione - S/N
    * sezione - numero ammissioni - ' ', 1, 2, 3, ...

Quindi il generatore di foglio excel deve anche gestire
una cosa finora mancante che è la lista dei codici
distinzioni onorificenze. Per FIAF.
Per FIAP c'è una regola diversa, ovvero ci sono
parti in comune come le indicazioni dell'autore,
ma richiede anche la nazionalità e un foglio per ogni tema
e sezione.

FIAF richiede un secondo report excel, che riguarda l'elenco delle foto partecipanti, in questo caso dopo la riga 1 che contiene il nome completo del concorso le colonne del foglio excel sono:

* codice patrocinio fiaf
* cognome autore
* nome autore
* codice fiscale (uno dei campi user_contact_mores)
* tessera fiaf (uno dei campi user_contact_mores)
* onorificenza fiaf
* una codifica della sezione a standard fiaf
  distinguendo tra STBN stampe monocromatiche **no**,
  CLP stampe a colori **no**, DIG digitali **sì, dig sì**, oppure senza sigle
  Portfolio Stampe e Portfolio digitale.
* il codice sezione
* il titolo della foto che segue la regola della federazione di riportare all'interno l'anno di prima ammissione,
* anno prima ammissione (viene estratto dal titolo?)
* Esito giuria 1 (ammissione) / 0 (non ammessa)
* premio assegnato (viene confrontato con il verbale)

### Onorificenze e distinzioni

Si può fare facilmente con un campo da inserire in user_contact_more, la regola di validazione potrebbe
essere realizzata sulla base di una lista memorizzata
in una ipotetica tabella delle distinzioni federation_distinction_codes. stringa > array di codici separati da spazio > convalida di ciascuno > stringa
