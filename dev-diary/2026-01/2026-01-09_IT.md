# Diario dello sviluppatore, data 9 gennaio 2026

* [index](../index.md) |
  [project](https://github.com/users/mrai64/projects/1/views/1?filterQuery=is%3Aopen&sortedBy%5Bdirection%5D=asc&sortedBy%5BcolumnId%5D=Title) issue list |
  [To Do List](../TDL.md) svuotato  

* [Route](/routes/web.php)

* [◀️ Diario di ieri](./2026-01-08_IT.md)

* run <http://yapcp.test/>
* User Doc <http://yapcp.test/docs/1.0/> [index](/resources/docs/1.0/index.md)
* [log](/storage/logs/laravel-2026-01-09.log)  | ngnix log  `open ~/Library/Application\ Support/Herd/Log`  `open ./storage/logs/`

## Today Do list

* Refactor scarico excel

## next step: revisione scarico fogli excel

* **Fatto** lo scarico din un foglio excel "vuoto"
* **Fatto** lo scarico di un elenco partecipanti
* **Fatto** lo scarico di un elenco partecipanti con le sezioni
* **Da fare** riordinare il materiale

Attualmente le federazioni prese in esame sono: una.
Le federazioni che concedono patrocinio però non sono una manciata,
e la reportistica va preparata anche per chi NON ha concorsi a
patrocinio federale. I report possono essere 2 come per la FIAF,
uno dei partecipanti con il numero delle ammissioni e uno
delle opere con il risultato di ammissione.

Dovrei quindi prevedere dei blocchi di route-controller-export-view
dedicati ognuno a un report, distinguendoli per federazione
(si può usare il federation_id, tradotto in minuscola per questioni di file)
e per versione, se per esempio la federazione dal prossimo anno
si inventa che l'anno di prima ammissione deve essere
una colonna del report, nel report dei concorsi deve mancare
fino a quando ci saanno dei concorsi soggetti alla regola nuova.

Alla tabella federation si affianca quindi uan tabella
federation_reports? dovrei prevedere una classe
enerica e poi stabilire in base a qualcsa come l'elenco
delle sponsorizzazioni qual'è la federazione coinvolta
e in base a quello andare a chiamare (php con istruzione switch?)
il costruttore esportatore appropriato. Fare si può fare.

## Chiedi a gemini come fare i test

[Chiedi a gemini](./2026-01-09_gemini_say_1.md)

Qui spiega che ci sno piùtipi di test, i "livelli base"
sono i test di funzione (chiamo somma 2 2 verifico esca 4)
e i test di interfaccia (chiamo home, in risposta ho uno status 200 e qualcos'altro).

I test hanno un input predefinito e un risultato atteso.
Il risultato atteso può anche essere un messaggio di errore,
fatto sta che anche i test hanno il loro `make:qualcosa`.

Poi c'è lo step successivo: far girare le verifiche ogni volta che faccio un push. questo però copmorta che devo separare il dev-diary
dal repository, non ha senzo fare i contrilli ogni volta
che mando su un aggiornamento del *delirio di uno sviluppatore*.
